"use strict";

require("source-map-support/register");

const {
  _,
  getValueByPath
} = require('rk-utils');

const spawn = require('child_process').spawn;

exports.withProps = (Base, Props) => class extends Base {
  constructor(...args) {
    super(...args);
    Object.assign(this, Props);
  }

};

exports.dependsOn = function (features, app, fromFeature) {
  let hasNotEnabled = _.find(_.castArray(features), feature => !app.enabled(feature));

  if (hasNotEnabled) {
    throw new Error(`"${fromFeature}" feature requires "${hasNotEnabled}" feature to be enabled.`);
  }
};

exports.tryRequire = function (packageName) {
  function tryRequireBy(packageName, mainModule, throwWhenNotFound) {
    try {
      return mainModule.require(packageName);
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        if (throwWhenNotFound) {
          let pkgPaths = packageName.split('/');
          let npmPkgName = pkgPaths[0];

          if (pkgPaths[0].startsWith('@') && pkgPaths.length > 1) {
            npmPkgName += '/' + pkgPaths[1];
          }

          console.log(error.message);
          throw new Error(`Module "${packageName}" not found. Try run "npm install ${npmPkgName}" to install the dependency.`);
        }

        return undefined;
      }

      throw error;
    }
  }

  return tryRequireBy(packageName, module, require.main === module) || tryRequireBy(packageName, require.main, true);
};

exports.restart = function (envVariables) {
  let processOptions = {
    env: { ...process.env,
      ...envVariables
    },
    detached: true,
    stdio: 'ignore'
  };
  let cp = spawn(process.argv[0], process.argv.slice(1), processOptions);
  cp.unref();
  process.exit(0);
};

exports.requireConfig = function (app, config, keys, prefix) {
  const {
    InvalidConfiguration
  } = require('./Errors');

  keys.forEach(key => {
    let value = getValueByPath(config, key);

    if (_.isNil(value)) {
      throw new InvalidConfiguration(`Missing required config item "${key}".`, app, `${prefix}.${key}`);
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9IZWxwZXJzLmpzIl0sIm5hbWVzIjpbIl8iLCJnZXRWYWx1ZUJ5UGF0aCIsInJlcXVpcmUiLCJzcGF3biIsImV4cG9ydHMiLCJ3aXRoUHJvcHMiLCJCYXNlIiwiUHJvcHMiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJPYmplY3QiLCJhc3NpZ24iLCJkZXBlbmRzT24iLCJmZWF0dXJlcyIsImFwcCIsImZyb21GZWF0dXJlIiwiaGFzTm90RW5hYmxlZCIsImZpbmQiLCJjYXN0QXJyYXkiLCJmZWF0dXJlIiwiZW5hYmxlZCIsIkVycm9yIiwidHJ5UmVxdWlyZSIsInBhY2thZ2VOYW1lIiwidHJ5UmVxdWlyZUJ5IiwibWFpbk1vZHVsZSIsInRocm93V2hlbk5vdEZvdW5kIiwiZXJyb3IiLCJjb2RlIiwicGtnUGF0aHMiLCJzcGxpdCIsIm5wbVBrZ05hbWUiLCJzdGFydHNXaXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJtYWluIiwicmVzdGFydCIsImVudlZhcmlhYmxlcyIsInByb2Nlc3NPcHRpb25zIiwiZW52IiwicHJvY2VzcyIsImRldGFjaGVkIiwic3RkaW8iLCJjcCIsImFyZ3YiLCJzbGljZSIsInVucmVmIiwiZXhpdCIsInJlcXVpcmVDb25maWciLCJjb25maWciLCJrZXlzIiwicHJlZml4IiwiSW52YWxpZENvbmZpZ3VyYXRpb24iLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJpc05pbCJdLCJtYXBwaW5ncyI6Ijs7OztBQUtDLE1BQU07QUFBRUEsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQTtBQUFMLElBQXdCQyxPQUFPLENBQUMsVUFBRCxDQUFyQzs7QUFDQSxNQUFNQyxLQUFLLEdBQUdELE9BQU8sQ0FBQyxlQUFELENBQVAsQ0FBeUJDLEtBQXZDOztBQVFEQyxPQUFPLENBQUNDLFNBQVIsR0FBb0IsQ0FBQ0MsSUFBRCxFQUFPQyxLQUFQLEtBQWlCLGNBQWNELElB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QUFxQztBQUN6RCxRQUFNO0FBQUVDLElBQUFBO0FBQUYsTUFBMkJ0RCxPQUFPLENBQUMsVUFBRCxDQUF4Qzs7QUFFQW9ELEVBQUFBLElBQUksQ0FBQ0csT0FBTCxDQUFhQyxHQUFHLElBQUk7QUFDaEIsUUFBSUMsS0FBSyxHQUFHMUQsY0FBYyxDQUFDb0QsTUFBRCxFQUFTSyxHQUFULENBQTFCOztBQUNBLFFBQUkxRCxDQUFDLENBQUM0RCxLQUFGLENBQVFELEtBQVIsQ0FBSixFQUFvQjtBQUNoQixZQUFNLElBQUlILG9CQUFKLENBQTBCLGlDQUFnQ0UsR0FBSSxJQUE5RCxFQUFtRTVDLEdBQW5FLEVBQXlFLEdBQUV5QyxNQUFPLElBQUdHLEdBQUksRUFBekYsQ0FBTjtBQUNIO0FBQ0osR0FMRDtBQU1ILENBVEQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbW1vbiBoZWxwZXJzIGZvciBzZXJ2aWNlIGNvbnRhaW5lci5cbiAqIEBtb2R1bGUgSGVscGVyc1xuICovIFxuXG4gY29uc3QgeyBfLCBnZXRWYWx1ZUJ5UGF0aCB9ID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbiBjb25zdCBzcGF3biA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5zcGF3bjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNsYXNzIG1peGluZyB3aXRoIGdpdmVuIHByb3BlcnRpZXMgYW5kIGluaXRpYWwgdmFsdWVzLlxuICogQG1peGluXG4gKiBAcGFyYW0geyp9IEJhc2UgXG4gKiBAcGFyYW0ge29iamVjdH0gUHJvcHMgXG4gKi9cbmV4cG9ydHMud2l0aFByb3BzID0gKEJhc2UsIFByb3BzKSA9PiBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBQcm9wcyk7XG4gICAgfVxufTtcblxuIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5LjxzdHJpbmc+fSBmZWF0dXJlcyAtIERlcGVuZGVuY2llcyBvZiBvdGhlciBmZWF0dXJlcy5cbiAgKiBAcGFyYW0ge1NlcnZpY2VDb250YWluZXJ9IGFwcCAtIE9yaWdpbiBzZXJ2aWNlIGNvbnRhaW5lciBhcHAuXG4gICogQHBhcmFtIHtzdHJpbmd9IGZyb21GZWF0dXJlIC0gRGVwZW5kZW50IGZlYXR1cmUuXG4gICovXG5leHBvcnRzLmRlcGVuZHNPbiA9IGZ1bmN0aW9uIChmZWF0dXJlcywgYXBwLCBmcm9tRmVhdHVyZSkge1xuICAgIGxldCBoYXNOb3RFbmFibGVkID0gXy5maW5kKF8uY2FzdEFycmF5KGZlYXR1cmVzKSwgZmVhdHVyZSA9PiAhYXBwLmVuYWJsZWQoZmVhdHVyZSkpO1xuXG4gICAgaWYgKGhhc05vdEVuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZnJvbUZlYXR1cmV9XCIgZmVhdHVyZSByZXF1aXJlcyBcIiR7aGFzTm90RW5hYmxlZH1cIiBmZWF0dXJlIHRvIGJlIGVuYWJsZWQuYCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcnkgcmVxdWlyZSBhIHBhY2thZ2UgbW9kdWxlIGFuZCBzaG93IGluc3RhbGwgdGlwcyBpZiBub3QgZm91bmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFja2FnZU5hbWVcbiAqL1xuZXhwb3J0cy50cnlSZXF1aXJlID0gZnVuY3Rpb24gKHBhY2thZ2VOYW1lKSB7XG5cbiAgICBmdW5jdGlvbiB0cnlSZXF1aXJlQnkocGFja2FnZU5hbWUsIG1haW5Nb2R1bGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWFpbk1vZHVsZS5yZXF1aXJlKHBhY2thZ2VOYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBrZ1BhdGhzID0gcGFja2FnZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5wbVBrZ05hbWUgPSBwa2dQYXRoc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBrZ1BhdGhzWzBdLnN0YXJ0c1dpdGgoJ0AnKSAmJiBwa2dQYXRocy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBucG1Qa2dOYW1lICs9ICcvJyArIHBrZ1BhdGhzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2R1bGUgXCIke3BhY2thZ2VOYW1lfVwiIG5vdCBmb3VuZC4gVHJ5IHJ1biBcIm5wbSBpbnN0YWxsICR7bnBtUGtnTmFtZX1cIiB0byBpbnN0YWxsIHRoZSBkZXBlbmRlbmN5LmApO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnlSZXF1aXJlQnkocGFja2FnZU5hbWUsIG1vZHVsZSwgcmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHx8IHRyeVJlcXVpcmVCeShwYWNrYWdlTmFtZSwgcmVxdWlyZS5tYWluLCB0cnVlKTtcbn07XG5cblxuLyoqXG4gKiBSZXN0YXJ0IHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gZW52VmFyaWFibGVzIC0gRW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmV4cG9ydHMucmVzdGFydCA9IGZ1bmN0aW9uIChlbnZWYXJpYWJsZXMpIHtcbiAgICBsZXQgcHJvY2Vzc09wdGlvbnMgPSB7ICAgICAgICBcbiAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5lbnZWYXJpYWJsZXMgfSxcbiAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgIHN0ZGlvOiAnaWdub3JlJ1xuICAgIH07XG5cbiAgICBsZXQgY3AgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIHByb2Nlc3MuYXJndi5zbGljZSgxKSwgcHJvY2Vzc09wdGlvbnMpO1xuICAgIGNwLnVucmVmKCk7XG4gICAgcHJvY2Vzcy5leGl0KDApO1xufTtcblxuZXhwb3J0cy5yZXF1aXJlQ29uZmlnID0gZnVuY3Rpb24gKGFwcCwgY29uZmlnLCBrZXlzLCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IEludmFsaWRDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL0Vycm9ycycpO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlQnlQYXRoKGNvbmZpZywga2V5KTtcbiAgICAgICAgaWYgKF8uaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24oYE1pc3NpbmcgcmVxdWlyZWQgY29uZmlnIGl0ZW0gXCIke2tleX1cIi5gLCBhcHAsIGAke3ByZWZpeH0uJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICB9KVxufTsiXX0=