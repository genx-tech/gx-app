"use strict";

require("source-map-support/register");

const {
  _,
  getValueByPath
} = require('rk-utils');

const spawn = require('child_process').spawn;

const {
  InvalidConfiguration
} = require('./Errors');

exports.withErrorCode = (Base, CODE) => {
  var _temp;

  return _temp = class extends Base {
    constructor(...args) {
      super(...args);
      this.code = CODE;
    }

  }, _temp;
};

exports.dependsOn = function (features, app, fromFeature) {
  let hasNotEnabled = _.find(_.castArray(features), feature => !app.enabled(feature));

  if (hasNotEnabled) {
    throw new Error(`"${fromFeature}" feature requires "${hasNotEnabled}" feature to be enabled.`);
  }
};

exports.tryRequire = function (packageName) {
  function tryRequireBy(packageName, mainModule, throwWhenNotFound) {
    try {
      return mainModule.require(packageName);
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        if (throwWhenNotFound) {
          let pkgPaths = packageName.split('/');
          let npmPkgName = pkgPaths[0];

          if (pkgPaths[0].startsWith('@') && pkgPaths.length > 1) {
            npmPkgName += '/' + pkgPaths[1];
          }

          console.log(error.message);
          throw new Error(`Module "${packageName}" not found. Try run "npm install ${npmPkgName}" to install the dependency.`);
        }

        return undefined;
      }

      throw error;
    }
  }

  return tryRequireBy(packageName, module, require.main === module) || tryRequireBy(packageName, require.main, true);
};

exports.restart = function (envVariables) {
  let processOptions = {
    env: { ...process.env,
      ...envVariables
    },
    detached: true,
    stdio: 'ignore'
  };
  let cp = spawn(process.argv[0], process.argv.slice(1), processOptions);
  cp.unref();
  process.exit(0);
};

exports.requireConfig = function (app, config, keys, prefix) {
  keys.forEach(key => {
    let value = getValueByPath(config, key);

    if (_.isNil(value)) {
      throw new InvalidConfiguration(`Missing required config item "${key}".`, app, `${prefix}.${key}`);
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9IZWxwZXJzLmpzIl0sIm5hbWVzIjpbIl8iLCJnZXRWYWx1ZUJ5UGF0aCIsInJlcXVpcmUiLCJzcGF3biIsIkludmFsaWRDb25maWd1cmF0aW9uIiwiZXhwb3J0cyIsIndpdGhFcnJvckNvZGUiLCJCYXNlIiwiQ09ERSIsImNvZGUiLCJkZXBlbmRzT24iLCJmZWF0dXJlcyIsImFwcCIsImZyb21GZWF0dXJlIiwiaGFzTm90RW5hYmxlZCIsImZpbmQiLCJjYXN0QXJyYXkiLCJmZWF0dXJlIiwiZW5hYmxlZCIsIkVycm9yIiwidHJ5UmVxdWlyZSIsInBhY2thZ2VOYW1lIiwidHJ5UmVxdWlyZUJ5IiwibWFpbk1vZHVsZSIsInRocm93V2hlbk5vdEZvdW5kIiwiZXJyb3IiLCJwa2dQYXRocyIsInNwbGl0IiwibnBtUGtnTmFtZSIsInN0YXJ0c1dpdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsIm1vZHVsZSIsIm1haW4iLCJyZXN0YXJ0IiwiZW52VmFyaWFibGVzIiwicHJvY2Vzc09wdGlvbnMiLCJlbnYiLCJwcm9jZXNzIiwiZGV0YWNoZWQiLCJzdGRpbyIsImNwIiwiYXJndiIsInNsaWNlIiwidW5yZWYiLCJleGl0IiwicmVxdWlyZUNvbmZpZyIsImNvbmZpZyIsImtleXMiLCJwcmVmaXgiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJpc05pbCJdLCJtYXBwaW5ncyI6Ijs7OztBQUtDLE1BQU07QUFBRUEsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQTtBQUFMLElBQXdCQyxPQUFPLENBQUMsVUFBRCxDQUFyQzs7QUFDQSxNQUFNQyxLQUFLLEdBQUdELE9BQU8sQ0FBQyxlQUFELENBQVAsQ0FBeUJDLEtBQXZDOztBQUNBLE1BQU07QUFBRUMsRUFBQUE7QUFBRixJQUEyQkYsT0FBTyxDQUFDLFVBQUQsQ0FBeEM7O0FBUURHLE9BQU8sQ0FBQ0MsYUFBUixHQUF3QixDQUFDQyxJQUFELEVBQU9D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TCxDQUFhQyxHQUFHLElBQUk7QUFDaEIsUUFBSUMsS0FBSyxHQUFHdEQsY0FBYyxDQUFDaUQsTUFBRCxFQUFTSSxHQUFULENBQTFCOztBQUNBLFFBQUl0RCxDQUFDLENBQUN3RCxLQUFGLENBQVFELEtBQVIsQ0FBSixFQUFvQjtBQUNoQixZQUFNLElBQUluRCxvQkFBSixDQUEwQixpQ0FBZ0NrRCxHQUFJLElBQTlELEVBQW1FMUMsR0FBbkUsRUFBeUUsR0FBRXdDLE1BQU8sSUFBR0UsR0FBSSxFQUF6RixDQUFOO0FBQ0g7QUFDSixHQUxEO0FBTUgsQ0FQRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tbW9uIGhlbHBlcnMgZm9yIHNlcnZpY2UgY29udGFpbmVyLlxuICogQG1vZHVsZSBIZWxwZXJzXG4gKi8gXG5cbiBjb25zdCB7IF8sIGdldFZhbHVlQnlQYXRoIH0gPSByZXF1aXJlKCdyay11dGlscycpO1xuIGNvbnN0IHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xuIGNvbnN0IHsgSW52YWxpZENvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vRXJyb3JzJyk7XG5cbiAvKipcbiAqIEZpbGwgYW4gZXJyb3IgY29kZSB0aGUgdGhlIGVycm9yIG9iamVjdC5cbiAqIEBtaXhpblxuICogQHBhcmFtIHsqfSBCYXNlIFxuICogQHBhcmFtIHsqfSBDT0RFIFxuICovXG5leHBvcnRzLndpdGhFcnJvckNvZGUgPSAoQmFzZSwgQ09ERSkgPT4gY2xhc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBjb2RlID0gQ09ERTtcbn07XG5cbiAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheS48c3RyaW5nPn0gZmVhdHVyZXMgLSBEZXBlbmRlbmNpZXMgb2Ygb3RoZXIgZmVhdHVyZXMuXG4gICogQHBhcmFtIHtTZXJ2aWNlQ29udGFpbmVyfSBhcHAgLSBPcmlnaW4gc2VydmljZSBjb250YWluZXIgYXBwLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRmVhdHVyZSAtIERlcGVuZGVudCBmZWF0dXJlLlxuICAqL1xuZXhwb3J0cy5kZXBlbmRzT24gPSBmdW5jdGlvbiAoZmVhdHVyZXMsIGFwcCwgZnJvbUZlYXR1cmUpIHtcbiAgICBsZXQgaGFzTm90RW5hYmxlZCA9IF8uZmluZChfLmNhc3RBcnJheShmZWF0dXJlcyksIGZlYXR1cmUgPT4gIWFwcC5lbmFibGVkKGZlYXR1cmUpKTtcblxuICAgIGlmIChoYXNOb3RFbmFibGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2Zyb21GZWF0dXJlfVwiIGZlYXR1cmUgcmVxdWlyZXMgXCIke2hhc05vdEVuYWJsZWR9XCIgZmVhdHVyZSB0byBiZSBlbmFibGVkLmApO1xuICAgIH1cbn07XG5cbi8qKlxuICogVHJ5IHJlcXVpcmUgYSBwYWNrYWdlIG1vZHVsZSBhbmQgc2hvdyBpbnN0YWxsIHRpcHMgaWYgbm90IGZvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhY2thZ2VOYW1lXG4gKi9cbmV4cG9ydHMudHJ5UmVxdWlyZSA9IGZ1bmN0aW9uIChwYWNrYWdlTmFtZSkge1xuXG4gICAgZnVuY3Rpb24gdHJ5UmVxdWlyZUJ5KHBhY2thZ2VOYW1lLCBtYWluTW9kdWxlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1haW5Nb2R1bGUucmVxdWlyZShwYWNrYWdlTmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwa2dQYXRocyA9IHBhY2thZ2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBucG1Qa2dOYW1lID0gcGtnUGF0aHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwa2dQYXRoc1swXS5zdGFydHNXaXRoKCdAJykgJiYgcGtnUGF0aHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnBtUGtnTmFtZSArPSAnLycgKyBwa2dQYXRoc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlIFwiJHtwYWNrYWdlTmFtZX1cIiBub3QgZm91bmQuIFRyeSBydW4gXCJucG0gaW5zdGFsbCAke25wbVBrZ05hbWV9XCIgdG8gaW5zdGFsbCB0aGUgZGVwZW5kZW5jeS5gKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ5UmVxdWlyZUJ5KHBhY2thZ2VOYW1lLCBtb2R1bGUsIHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB8fCB0cnlSZXF1aXJlQnkocGFja2FnZU5hbWUsIHJlcXVpcmUubWFpbiwgdHJ1ZSk7XG59O1xuXG5cbi8qKlxuICogUmVzdGFydCB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogQHBhcmFtIHtvYmplY3R9IGVudlZhcmlhYmxlcyAtIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICovXG5leHBvcnRzLnJlc3RhcnQgPSBmdW5jdGlvbiAoZW52VmFyaWFibGVzKSB7XG4gICAgbGV0IHByb2Nlc3NPcHRpb25zID0geyAgICAgICAgXG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgLi4uZW52VmFyaWFibGVzIH0sXG4gICAgICAgIGRldGFjaGVkOiB0cnVlLFxuICAgICAgICBzdGRpbzogJ2lnbm9yZSdcbiAgICB9O1xuXG4gICAgbGV0IGNwID0gc3Bhd24ocHJvY2Vzcy5hcmd2WzBdLCBwcm9jZXNzLmFyZ3Yuc2xpY2UoMSksIHByb2Nlc3NPcHRpb25zKTtcbiAgICBjcC51bnJlZigpO1xuICAgIHByb2Nlc3MuZXhpdCgwKTtcbn07XG5cbmV4cG9ydHMucmVxdWlyZUNvbmZpZyA9IGZ1bmN0aW9uIChhcHAsIGNvbmZpZywga2V5cywgcHJlZml4KSB7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlQnlQYXRoKGNvbmZpZywga2V5KTtcbiAgICAgICAgaWYgKF8uaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24oYE1pc3NpbmcgcmVxdWlyZWQgY29uZmlnIGl0ZW0gXCIke2tleX1cIi5gLCBhcHAsIGAke3ByZWZpeH0uJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICB9KVxufSJdfQ==