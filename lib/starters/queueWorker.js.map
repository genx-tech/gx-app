{"version":3,"sources":["../../src/starters/queueWorker.js"],"names":["startWorker","require","startQueueWorker","worker","queueService","queueName","options","workerName","workerOptions","app","messageQueue","getService","log","workerConsume_","channel","msg","info","content","JSON","parse","toString","error","ack","$mock","raw","then","shouldAck","nack","catch","message","stack","needRetry","dontStop","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,UAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeC,gBAAf,CAAgCC,MAAhC,EAAwCC,YAAxC,EAAsDC,SAAtD,EAAiEC,OAAjE,EAA0E;AACtE,MAAI;AAAEC,IAAAA,UAAF;AAAc,OAAGC;AAAjB,MAAmCF,OAAvC;;AAEA,MAAI,CAACC,UAAL,EAAiB;AACbA,IAAAA,UAAU,GAAGF,SAAS,GAAG,QAAzB;AACH;;AAED,SAAOL,WAAW,CAAC,MAAOS,GAAP,IAAe;AAC9B,QAAIC,YAAY,GAAGD,GAAG,CAACE,UAAJ,CAAeP,YAAf,CAAnB;AAEAK,IAAAA,GAAG,CAACG,GAAJ,CAAQ,MAAR,EAAiB,+DAA8DP,SAAU,OAAzF;AAEA,UAAMK,YAAY,CAACG,cAAb,CAA4BR,SAA5B,EAAuC,CAACS,OAAD,EAAUC,GAAV,KAAkB;AAC3D,UAAIC,IAAI,GAAGD,GAAG,IAAIA,GAAG,CAACE,OAAtB;;AAEA,UAAI;AACAD,QAAAA,IAAI,GAAGA,IAAI,IAAIE,IAAI,CAACC,KAAL,CAAWH,IAAI,CAACI,QAAL,EAAX,CAAf;AACH,OAFD,CAEE,OAAOC,KAAP,EAAc;AACZZ,QAAAA,GAAG,CAACG,GAAJ,CAAQ,OAAR,EAAiB,kDAAjB;AACAE,QAAAA,OAAO,CAACQ,GAAR,CAAYP,GAAZ;AACA;AACH;;AAED,UAAIC,IAAI,IAAIA,IAAI,CAACO,KAAjB,EAAwB;AACpBd,QAAAA,GAAG,CAACG,GAAJ,CAAQ,MAAR,EAAgB,2CAA2CY,GAA3D;AACAV,QAAAA,OAAO,CAACQ,GAAR,CAAYP,GAAZ;AACA;AACH;;AAEDZ,MAAAA,MAAM,CAACM,GAAD,EAAMO,IAAN,CAAN,CAAkBS,IAAlB,CAAuBC,SAAS,IAAI;AAChC,YAAIA,SAAJ,EAAe;AACXZ,UAAAA,OAAO,CAACQ,GAAR,CAAYP,GAAZ;AACH,SAFD,MAEO;AACHD,UAAAA,OAAO,CAACa,IAAR,CAAaZ,GAAb;AACH;AACJ,OAND,EAMGa,KANH,CAMSP,KAAK,IAAI;AACdZ,QAAAA,GAAG,CAACG,GAAJ,CAAQ,OAAR,EAAiBS,KAAK,CAACQ,OAAvB,EAAgC,EAAE,GAAGR,KAAK,CAACL,IAAX;AAAiBc,UAAAA,KAAK,EAAET,KAAK,CAACS;AAA9B,SAAhC;;AAEA,YAAIT,KAAK,CAACU,SAAV,EAAqB;AACjBjB,UAAAA,OAAO,CAACa,IAAR,CAAaZ,GAAb;AACH,SAFD,MAEO;AACHD,UAAAA,OAAO,CAACQ,GAAR,CAAYP,GAAZ;AACH;AACJ,OAdD;AAeH,KAhCK,CAAN;AAkCH,GAvCiB,EAuCf,EAAE,GAAGP,aAAL;AAAoBD,IAAAA,UAApB;AAAgCyB,IAAAA,QAAQ,EAAE;AAA1C,GAvCe,CAAlB;AAwCH;;AAEDC,MAAM,CAACC,OAAP,GAAiBhC,gBAAjB","sourcesContent":["\"use strict\";\n\nconst startWorker = require('./worker');\n\n/**\n * Start a message queue worker.\n * @param {Function} worker  \n * @param {*} queueService \n * @param {*} queueName  \n * @param {object} options \n */\nasync function startQueueWorker(worker, queueService, queueName, options) {    \n    let { workerName, ...workerOptions } = options;\n\n    if (!workerName) {\n        workerName = queueName + 'Worker';\n    }  \n\n    return startWorker(async (app) => {\n        let messageQueue = app.getService(queueService);\n\n        app.log('info', `A queue worker is started and waiting for message on queue \"${queueName}\" ...`);\n\n        await messageQueue.workerConsume_(queueName, (channel, msg) => {            \n            let info = msg && msg.content;\n\n            try {\n                info = info && JSON.parse(info.toString());\n            } catch (error) {\n                app.log('error', 'The incoming message is not a valid JSON string.');\n                channel.ack(msg);  \n                return;\n            }\n\n            if (info && info.$mock) {\n                app.log('info', 'A mock message is received.\\nMessage: ' + raw);\n                channel.ack(msg);  \n                return;\n            }\n\n            worker(app, info).then(shouldAck => {\n                if (shouldAck) {                    \n                    channel.ack(msg);  \n                } else {\n                    channel.nack(msg);  \n                }                    \n            }).catch(error => {\n                app.log('error', error.message, { ...error.info, stack: error.stack });\n\n                if (error.needRetry) {\n                    channel.nack(msg);  \n                } else {\n                    channel.ack(msg);\n                } \n            });            \n        });\n\n    }, { ...workerOptions, workerName, dontStop: true });\n}\n\nmodule.exports = startQueueWorker;"],"file":"queueWorker.js"}