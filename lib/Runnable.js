"use strict";require("source-map-support/register");function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return typeof key==="symbol"?key:String(key)}function _toPrimitive(input,hint){if(typeof input!=="object"||input===null)return input;var prim=input[Symbol.toPrimitive];if(prim!==undefined){var res=prim.call(input,hint||"default");if(typeof res!=="object")return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return(hint==="string"?String:Number)(input)}const{_,sleep_,eachAsync_}=require("@genx/july");const winston=require("winston");const winstonFlight=require("winstonflight");const Logger=require("winston/lib/winston/logger");const Runnable=T=>class extends T{constructor(name,options){super(name,{logger:{"useMetaKey":"metadata","level":"info","transports":[{"type":"console","options":{"format":winston.format.combine(winston.format.colorize(),winston.format.simple())}}],...(options&&options.logger)},exitOnUncaught:true,appModulesPath:"libs",..._.omit(options,["logger"])});_defineProperty(this,"_getOnUncaughtException",exitOnError=>err=>{if(exitOnError){let waitForLogging=setTimeout(()=>{process.exit(1)},1000);this.log("error",err,()=>{clearTimeout(waitForLogging);process.exit(1)})}else{this.logError(err)}});_defineProperty(this,"_onWarning",warning=>{this.log("warn",warning.message)});_defineProperty(this,"_onExit",code=>{if(this.started){this.stop_().catch(this.logError)}});this.runnable=true}async start_(){this._initialize();process.on("exit",this._onExit);return super.start_()}async stop_(){if(this.started){if(this.libModules){await eachAsync_(this.libModules,lib=>lib.stop_());delete this.libModules}}process.removeListener("exit",this._onExit);await super.stop_();await sleep_(0);this._uninitialize()}getLib(libName){if(!this.libModules){throw new Error("\"libModules\" feature is required to access lib among modules.")}let libModule=this.libModules[libName];if(!libModule){throw new Error(`Lib module [${libName}] not found.`)}return libModule}requireFromLib(libName,relativePath){let libModule=this.getLib(libName);return libModule.require(relativePath)}registerLib(lib){if(!this.libModules){this.libModules={}}this.libModules[lib.name]=lib}getService(name){let pos=name.indexOf("/");if(pos===-1){return super.getService(name)}let lib=name.substring(0,pos);name=name.substring(pos+1);let app=this.getLib(lib);return app&&app.getService(name,true)}resetLogger(){this._injectLogger(true);this._injectLogger()}_initialize(){this._pwd=process.cwd();if(this.workingPath!==this._pwd){process.chdir(this.workingPath)}this._injectLogger();this._injectErrorHandlers()}_uninitialize(){const detach=true;this._injectErrorHandlers(detach);this._injectLogger(detach);process.chdir(this._pwd);delete this._pwd}_injectLogger(detach){if(detach){this.log("verbose","Logger is detaching ...");if(!this._externalLogger){this.logger.close()}delete this._externalLogger;delete this.logger;return}if(this.options.logger instanceof Logger){this.logger=this.options.logger;this._externalLogger=true}else{const loggerOpt=_.cloneDeep(this.options.logger);if(loggerOpt.transports){loggerOpt.transports=winstonFlight(winston,loggerOpt.transports)}this.logger=winston.createLogger(loggerOpt)}this.log("verbose","Logger injected.")}_injectErrorHandlers(detach){if(detach){process.removeListener("warning",this._onWarning);if(this._onUncaughtException){process.removeListener("uncaughtException",this._onUncaughtException);delete this._onUncaughtException}this.log("verbose","Process-wide error handlers detached.");return}if(!this.options.ignoreUncaught){this._onUncaughtException=this._getOnUncaughtException(this.options.exitOnUncaught);process.on("uncaughtException",this._onUncaughtException)}process.on("warning",this._onWarning);this.log("verbose","Process-wide error handlers injected.")}};module.exports=Runnable;
//# sourceMappingURL=Runnable.js.map