"use strict";require("source-map-support/register");function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return typeof key==="symbol"?key:String(key)}function _toPrimitive(input,hint){if(typeof input!=="object"||input===null)return input;var prim=input[Symbol.toPrimitive];if(prim!==undefined){var res=prim.call(input,hint||"default");if(typeof res!=="object")return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return(hint==="string"?String:Number)(input)}const ConfigLoader=require("@genx/config");const JsonConfigProvider=require("@genx/config/lib/JsonConfigProvider");const{_,pushIntoBucket,eachAsync_}=require("@genx/july");const{fs,tryRequire:_tryRequire}=require("@genx/sys");const path=require("path");const EventEmitter=require("events");const winston=require("winston");const Feature=require("./enum/Feature");const Literal=require("./enum/Literal");class ServiceContainer extends EventEmitter{constructor(name,options){super();_defineProperty(this,"logError",(error,message)=>{return this.logException("error",error,message)});_defineProperty(this,"logErrorAsWarning",(error,message)=>{return this.logException("warn",error,message)});this.name=name;this.options=Object.assign({},options);this.env=this.options.env||process.env.NODE_ENV||"development";this.workingPath=this.options.workingPath?path.resolve(this.options.workingPath):process.cwd();this.configPath=this.toAbsolutePath(this.options.configPath||Literal.DEFAULT_CONFIG_PATH);this.configName=this.options.configName||Literal.APP_CFG_NAME}async start_(){this.log("verbose",`Starting app [${this.name}] ...`);this._featureRegistry={"*":this._getFeatureFallbackPath()};this.features={};this.services={};if(this.options.loadConfigFromOptions){this.config=this.options.config}else{this.configLoader=this.options.disableEnvAwareConfig?new ConfigLoader(new JsonConfigProvider(path.join(this.configPath,this.configName+".json")),this):ConfigLoader.createEnvAwareJsonLoader(this.configPath,this.configName,this.env,this);await this.loadConfig_()}this.emit("configLoaded");if(_.isEmpty(this.config)){throw Error("Empty configuration. Nothing to do! Config path: "+this.configPath)}await this._loadFeatures_();this.emit("ready");this.started=true;return this}async stop_(){await this.emitAsync_("stopping");this.log("verbose",`Stopping app [${this.name}] ...`);this.started=false;delete this.services;delete this.features;delete this._featureRegistry;delete this.config;delete this.configLoader;await this.emitAsync_("stopped");this.removeAllListeners()}async loadConfig_(){let configVariables=this._getConfigVariables();this.config=await this.configLoader.load_(configVariables);return this}toAbsolutePath(...args){if(args.length===0||args[0]==null){return this.workingPath}return path.resolve(this.workingPath,...args)}tryRequire(pkgName){return _tryRequire(pkgName,this.workingPath)}registerService(name,serviceObject,override){if(name in this.services&&!override){throw new Error("Service \""+name+"\" already registered!")}this.services[name]=serviceObject;this.log("verbose",`Service "${name}" registered.`);return this}hasService(name){return name in this.services}getService(name){return this.services[name]}enabled(feature){return this.features.hasOwnProperty(feature)}addFeatureRegistry(registry){if(registry.hasOwnProperty("*")){pushIntoBucket(this._featureRegistry,"*",registry["*"])}Object.assign(this._featureRegistry,_.omit(registry,["*"]))}log(level,message,...rest){this.logger&&this.logger.log(level,message,...rest);return this}logException(level,error,summary){this.log(level,(summary?summary+"\n":"")+error.message,_.pick(error,["name","status","code","info","stack","request"]));return this}replaceLogger(logger){if(logger){assert:!this._loggerBackup;this._loggerBackup=this.logger;this._externalLoggerBackup=this._externalLogger;this.logger=logger;this._externalLogger=true;this.log("verbose","A new app logger attached.")}else{this.logger=this._loggerBackup;this._externalLogger=this._externalLoggerBackup;delete this._loggerBackup;delete this._externalLoggerBackup;this.log("verbose","The current app logger is dettached.")}}_getConfigVariables(){const processInfo={env:process.env,arch:process.arch,argv:process.argv,cwd:process.cwd(),pid:process.pid,platform:process.platform};return{app:this,log:winston,env:this.env,process:processInfo}}_getFeatureFallbackPath(){return[path.resolve(__dirname,Literal.FEATURES_PATH),this.options.featuresPath?this.toAbsolutePath(this.options.featuresPath):this.toAbsolutePath(Literal.FEATURES_PATH)]}async emitAsync_(event){let asyncHandlers=[];this.emit(event,asyncHandlers);if(asyncHandlers.length>0){await Promise.all(asyncHandlers)}}async _loadFeatures_(){let configStageFeatures=[];_.forOwn(this.config,(featureOptions,name)=>{if(this.options.allowedFeatures&&this.options.allowedFeatures.indexOf(name)===-1){return}let feature;try{feature=this._loadFeature(name)}catch(err){}if(feature&&feature.type===Feature.CONF){configStageFeatures.push([name,feature.load_,featureOptions]);delete this.config[name]}});if(configStageFeatures.length>0){configStageFeatures.forEach(([name])=>{delete this.config[name]});await this._loadFeatureGroup_(configStageFeatures,Feature.CONF);return this._loadFeatures_()}let featureGroups={[Feature.INIT]:[],[Feature.SERVICE]:[],[Feature.PLUGIN]:[],[Feature.READY]:[]};_.forOwn(this.config,(featureOptions,name)=>{if(this.options.allowedFeatures&&this.options.allowedFeatures.indexOf(name)===-1){return}let feature=this._loadFeature(name);if(!(feature.type in featureGroups)){throw new Error(`Invalid feature type. Feature: ${name}, type: ${feature.type}`)}featureGroups[feature.type].push([name,feature.load_,featureOptions])});return eachAsync_(featureGroups,(group,level)=>this._loadFeatureGroup_(group,level))}async _loadFeatureGroup_(featureGroup,groupLevel){await this.emitAsync_("before:"+groupLevel);this.log("verbose",`Loading "${groupLevel}" feature group ...`);await eachAsync_(featureGroup,async([name,load_,options])=>{await this.emitAsync_("before:load:"+name);this.log("verbose",`Loading feature "${name}" ...`);await load_(this,options,name);this.features[name].loaded=true;this.log("verbose",`Feature "${name}" loaded. [OK]`);await this.emitAsync_("after:load:"+name)});this.log("verbose",`Finished loading "${groupLevel}" feature group. [OK]`);await this.emitAsync_("after:"+groupLevel)}_loadFeature(feature){let featureObject=this.features[feature];if(featureObject)return featureObject;let featurePath;if(this._featureRegistry.hasOwnProperty(feature)){let loadOption=this._featureRegistry[feature];if(Array.isArray(loadOption)){if(loadOption.length===0){throw new Error(`Invalid registry value for feature "${feature}".`)}featurePath=loadOption[0];featureObject=this.tryRequire(featurePath);if(loadOption.length>1){featureObject=_.get(featureObject,loadOption[1])}}else{featurePath=loadOption;featureObject=this.tryRequire(featurePath)}}else{let searchingPath=this._featureRegistry["*"];let found=_.findLast(searchingPath,p=>{featurePath=path.join(p,feature+".js");return fs.existsSync(featurePath)});if(!found){throw new Error(`Don't know where to load feature "${feature}".`)}featureObject=require(featurePath)}if(!Feature.validate(featureObject)){throw new Error(`Invalid feature object loaded from "${featurePath}".`)}this.features[feature]=featureObject;return featureObject}}module.exports=ServiceContainer;
//# sourceMappingURL=ServiceContainer.js.map