"use strict";

require("source-map-support/register");

const path = require("path");

const {
  _,
  eachAsync_
} = require("@genx/july");

const {
  fs
} = require("@genx/sys");

const Feature = require("../enum/Feature");

const {
  InvalidConfiguration
} = require("@genx/error");

module.exports = {
  type: Feature.PLUGIN,
  load_: async (server, entries) => {
    const {
      LibModule
    } = app.tryRequire('@genx/server');
    return eachAsync_(entries, async (config, name) => {
      let options = Object.assign({
        env: server.env,
        logWithAppName: server.options.logWithAppName
      }, config.options);
      let appPath;

      if (config.npmModule) {
        appPath = server.toAbsolutePath("node_modules", name);
      } else {
        const appModulesPath = server.appModulesPath || server.toAbsolutePath(server.options.appModulesPath);
        appPath = path.join(appModulesPath, name);
      }

      let exists = (await fs.pathExists(appPath)) && (await fs.stat(appPath)).isDirectory();

      if (!exists) {
        throw new InvalidConfiguration(`Lib [${name}] not exists.`, server, `libModules.${name}`);
      }

      let lib = new LibModule(server, name, appPath, options);
      lib.on("configLoaded", () => {
        if (!_.isEmpty(config.settings)) {
          lib.config.settings = Object.assign({}, lib.config.settings, config.settings);
          server.log("verbose", `Lib settings of [${lib.name}] is overrided.`);
        }
      });
      let relativePath = path.relative(server.workingPath, appPath);
      server.log("verbose", `Loading lib [${lib.name}] from "${relativePath}" ...`);
      await lib.start_();
      server.registerLib(lib);
      server.log("verbose", `Lib [${lib.name}] is loaded.`);
    });
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mZWF0dXJlcy9saWJNb2R1bGVzLmpzIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiXyIsImVhY2hBc3luY18iLCJmcyIsIkZlYXR1cmUiLCJJbnZhbGlkQ29uZmlndXJhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0eXBlIiwiUExVR0lOIiwibG9hZF8iLCJzZXJ2ZXIiLCJlbnRyaWVzIiwiTGliTW9kdWxlIiwiYXBwIiwidHJ5UmVxdWlyZSIsImNvbmZpZyIsIm5hbWUiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwiZW52IiwibG9nV2l0aEFwcE5hbWUiLCJhcHBQYXRoIiwibnBtTW9kdWxlIiwidG9BYnNvbHV0ZVBhdGgiLCJhcHBNb2R1bGVzUGF0aCIsImpvaW4iLCJleGlzdHMiLCJwYXRoRXhpc3RzIiwic3RhdCIsImlzRGlyZWN0b3J5IiwibGliIiwib24iLCJpc0VtcHR5Iiwic2V0dGluZ3MiLCJsb2ciLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsIndvcmtpbmdQYXRoIiwic3RhcnRfIiwicmVnaXN0ZXJMaWIiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBbUJBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxDQUFGO0FBQUtDLEVBQUFBO0FBQUwsSUFBb0JGLE9BQU8sQ0FBQyxZQUFELENBQWpDOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUFTSCxPQUFPLENBQUMsV0FBRCxDQUF0Qjs7QUFDQSxNQUFNSSxPQUFPLEdBQUdKLE9BQU8sQ0FBQyxpQkFBRCxDQUF2Qjs7QUFDQSxNQUFNO0FBQUVLLEVBQUFBO0FBQUYsSUFBMkJMLE9BQU8sQ0FBQyxhQUFELENBQXhDOztBQUVBTSxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFLYkMsRUFBQUEsSUFBSSxFQUFFSixPQUFPLENBQUNLLE1BTEQ7QUFhYkMsRUFBQUEsS0FBSyxFQUFFLE9BQU9DLE1BQVAsRUFBZUMsT0FBZixLQUEyQjtBQUM5QixVQUFNO0FBQUVDLE1BQUFBO0FBQUYsUUFBZ0JDLEdBQUcsQ0FBQ0MsVUFBSixDQUFlLGNBQWYsQ0FBdEI7QUFFQSxXQUFPYixVQUFVLENBQUNVLE9BQUQsRUFBVSxPQUFPSSxNQUFQLEVBQWVDLElBQWYsS0FBd0I7QUFDL0MsVUFBSUMsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FDVjtBQUNJQyxRQUFBQSxHQUFHLEVBQUVWLE1BQU0sQ0FBQ1UsR0FEaEI7QUFFSUMsUUFBQUEsY0FBYyxFQUFFWCxNQUFNLENBQUNPLE9BQVAsQ0FBZUk7QUFGbkMsT0FEVSxFQUtWTixNQUFNLENBQUNFLE9BTEcsQ0FBZDtBQVFBLFVBQUlLLE9BQUo7O0FBRUEsVUFBSVAsTUFBTSxDQUFDUSxTQUFYLEVBQXNCO0FBQ2xCRCxRQUFBQSxPQUFPLEdBQUdaLE1BQU0sQ0FBQ2MsY0FBUCxDQUFzQixjQUF0QixFQUFzQ1IsSUFBdEMsQ0FBVjtBQUNILE9BRkQsTUFFTztBQUNILGNBQU1TLGNBQWMsR0FBR2YsTUFBTSxDQUFDZSxjQUFQLElBQXlCZixNQUFNLENBQUNjLGNBQVAsQ0FBc0JkLE1BQU0sQ0FBQ08sT0FBUCxDQUFlUSxjQUFyQyxDQUFoRDtBQUNBSCxRQUFBQSxPQUFPLEdBQUd4QixJQUFJLENBQUM0QixJQUFMLENBQVVELGNBQVYsRUFBMEJULElBQTFCLENBQVY7QUFDSDs7QUFFRCxVQUFJVyxNQUFNLEdBQUcsQ0FBQyxNQUFNekIsRUFBRSxDQUFDMEIsVUFBSCxDQUFjTixPQUFkLENBQVAsS0FBa0MsQ0FBQyxNQUFNcEIsRUFBRSxDQUFDMkIsSUFBSCxDQUFRUCxPQUFSLENBQVAsRUFBeUJRLFdBQXpCLEVBQS9DOztBQUNBLFVBQUksQ0FBQ0gsTUFBTCxFQUFhO0FBQ1QsY0FBTSxJQUFJdkIsb0JBQUosQ0FBMEIsUUFBT1ksSUFBSyxlQUF0QyxFQUFzRE4sTUFBdEQsRUFBK0QsY0FBYU0sSUFBSyxFQUFqRixDQUFOO0FBQ0g7O0FBRUQsVUFBSWUsR0FBRyxHQUFHLElBQUluQixTQUFKLENBQWNGLE1BQWQsRUFBc0JNLElBQXRCLEVBQTRCTSxPQUE1QixFQUFxQ0wsT0FBckMsQ0FBVjtBQUVBYyxNQUFBQSxHQUFHLENBQUNDLEVBQUosQ0FBTyxjQUFQLEVBQXVCLE1BQU07QUFDekIsWUFBSSxDQUFDaEMsQ0FBQyxDQUFDaUMsT0FBRixDQUFVbEIsTUFBTSxDQUFDbUIsUUFBakIsQ0FBTCxFQUFpQztBQUM3QkgsVUFBQUEsR0FBRyxDQUFDaEIsTUFBSixDQUFXbUIsUUFBWCxHQUFzQmhCLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JZLEdBQUcsQ0FBQ2hCLE1BQUosQ0FBV21CLFFBQTdCLEVBQXVDbkIsTUFBTSxDQUFDbUIsUUFBOUMsQ0FBdEI7QUFDQXhCLFVBQUFBLE1BQU0sQ0FBQ3lCLEdBQVAsQ0FBVyxTQUFYLEVBQXVCLG9CQUFtQkosR0FBRyxDQUFDZixJQUFLLGlCQUFuRDtBQUNIO0FBQ0osT0FMRDtBQU9BLFVBQUlvQixZQUFZLEdBQUd0QyxJQUFJLENBQUN1QyxRQUFMLENBQWMzQixNQUFNLENBQUM0QixXQUFyQixFQUFrQ2hCLE9BQWxDLENBQW5CO0FBQ0FaLE1BQUFBLE1BQU0sQ0FBQ3lCLEdBQVAsQ0FBVyxTQUFYLEVBQXVCLGdCQUFlSixHQUFHLENBQUNmLElBQUssV0FBVW9CLFlBQWEsT0FBdEU7QUFFQSxZQUFNTCxHQUFHLENBQUNRLE1BQUosRUFBTjtBQUVBN0IsTUFBQUEsTUFBTSxDQUFDOEIsV0FBUCxDQUFtQlQsR0FBbkI7QUFFQXJCLE1BQUFBLE1BQU0sQ0FBQ3lCLEdBQVAsQ0FBVyxTQUFYLEVBQXVCLFFBQU9KLEdBQUcsQ0FBQ2YsSUFBSyxjQUF2QztBQUNILEtBeENnQixDQUFqQjtBQXlDSDtBQXpEWSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIExvYWQgbGliIG1vZHVsZXNcbiAqIEBtb2R1bGUgRmVhdHVyZV9MaWJNb2R1bGVzXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgJ2xpYk1vZHVsZXMnOiB7XG4gKiAgICAgICc8bmFtZT4nOiB7XG4gKiAgICAgICAgICBucG1Nb2R1bGU6IGZhbHNlLCAvLyB3aGV0aGVyIGlzIGEgbnBtIG1vZHVsZVxuICogICAgICAgICAgb3B0aW9uczogeyAvLyBtb2R1bGUgb3B0aW9uc1xuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHNldHRpbmdzOiB7IC8vIGNhbiBvdmVycmlkZSBtb2R1bGUgZGVmaW5lZCBzZXR0aW5nc1xuICogICAgICAgICAgfVxuICogICAgICB9XG4gKiAgfVxuICovXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHsgXywgZWFjaEFzeW5jXyB9ID0gcmVxdWlyZShcIkBnZW54L2p1bHlcIik7XG5jb25zdCB7IGZzIH0gPSByZXF1aXJlKFwiQGdlbngvc3lzXCIpO1xuY29uc3QgRmVhdHVyZSA9IHJlcXVpcmUoXCIuLi9lbnVtL0ZlYXR1cmVcIik7XG5jb25zdCB7IEludmFsaWRDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKFwiQGdlbngvZXJyb3JcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBsb2FkZWQgYXQgcGx1Z2luIHN0YWdlLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiBGZWF0dXJlLlBMVUdJTixcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtXZWJTZXJ2ZXJ9IHNlcnZlciAtIFRoZSB3ZWIgc2VydmVyIG1vZHVsZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVudHJpZXMgLSBMaWIgbW9kdWxlIGVudHJpZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPCo+fVxuICAgICAqL1xuICAgIGxvYWRfOiBhc3luYyAoc2VydmVyLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgTGliTW9kdWxlIH0gPSBhcHAudHJ5UmVxdWlyZSgnQGdlbngvc2VydmVyJyk7XG5cbiAgICAgICAgcmV0dXJuIGVhY2hBc3luY18oZW50cmllcywgYXN5bmMgKGNvbmZpZywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZW52OiBzZXJ2ZXIuZW52LFxuICAgICAgICAgICAgICAgICAgICBsb2dXaXRoQXBwTmFtZTogc2VydmVyLm9wdGlvbnMubG9nV2l0aEFwcE5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWcub3B0aW9uc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGFwcFBhdGg7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcubnBtTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgYXBwUGF0aCA9IHNlcnZlci50b0Fic29sdXRlUGF0aChcIm5vZGVfbW9kdWxlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwTW9kdWxlc1BhdGggPSBzZXJ2ZXIuYXBwTW9kdWxlc1BhdGggfHwgc2VydmVyLnRvQWJzb2x1dGVQYXRoKHNlcnZlci5vcHRpb25zLmFwcE1vZHVsZXNQYXRoKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXBwUGF0aCA9IHBhdGguam9pbihhcHBNb2R1bGVzUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBleGlzdHMgPSAoYXdhaXQgZnMucGF0aEV4aXN0cyhhcHBQYXRoKSkgJiYgKGF3YWl0IGZzLnN0YXQoYXBwUGF0aCkpLmlzRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29uZmlndXJhdGlvbihgTGliIFske25hbWV9XSBub3QgZXhpc3RzLmAsIHNlcnZlciwgYGxpYk1vZHVsZXMuJHtuYW1lfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGliID0gbmV3IExpYk1vZHVsZShzZXJ2ZXIsIG5hbWUsIGFwcFBhdGgsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBsaWIub24oXCJjb25maWdMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0VtcHR5KGNvbmZpZy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGliLmNvbmZpZy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGxpYi5jb25maWcuc2V0dGluZ3MsIGNvbmZpZy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5sb2coXCJ2ZXJib3NlXCIsIGBMaWIgc2V0dGluZ3Mgb2YgWyR7bGliLm5hbWV9XSBpcyBvdmVycmlkZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHNlcnZlci53b3JraW5nUGF0aCwgYXBwUGF0aCk7XG4gICAgICAgICAgICBzZXJ2ZXIubG9nKFwidmVyYm9zZVwiLCBgTG9hZGluZyBsaWIgWyR7bGliLm5hbWV9XSBmcm9tIFwiJHtyZWxhdGl2ZVBhdGh9XCIgLi4uYCk7XG5cbiAgICAgICAgICAgIGF3YWl0IGxpYi5zdGFydF8oKTtcblxuICAgICAgICAgICAgc2VydmVyLnJlZ2lzdGVyTGliKGxpYik7XG5cbiAgICAgICAgICAgIHNlcnZlci5sb2coXCJ2ZXJib3NlXCIsIGBMaWIgWyR7bGliLm5hbWV9XSBpcyBsb2FkZWQuYCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuIl19