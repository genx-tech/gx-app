"use strict";

require("source-map-support/register");

const path = require("path");

const {
  _,
  eachAsync_
} = require("@genx/july");

const {
  fs
} = require("@genx/sys");

const Feature = require("../enum/Feature");

const {
  InvalidConfiguration
} = require("@genx/error");

module.exports = {
  type: Feature.PLUGIN,
  load_: async (server, entries) => {
    const {
      LibModule
    } = server.tryRequire('@genx/server');
    return eachAsync_(entries, async (config, name) => {
      let options = Object.assign({
        env: server.env,
        logWithAppName: server.options.logWithAppName
      }, config.options);
      let appPath;

      if (config.npmModule) {
        appPath = server.toAbsolutePath("node_modules", name);
      } else {
        const appModulesPath = server.appModulesPath || server.toAbsolutePath(server.options.appModulesPath);
        appPath = path.join(appModulesPath, name);
      }

      let exists = (await fs.pathExists(appPath)) && (await fs.stat(appPath)).isDirectory();

      if (!exists) {
        throw new InvalidConfiguration(`Lib [${name}] not exists.`, server, `libModules.${name}`);
      }

      let lib = new LibModule(server, name, appPath, options);
      lib.on("configLoaded", () => {
        if (!_.isEmpty(config.settings)) {
          lib.config.settings = Object.assign({}, lib.config.settings, config.settings);
          server.log("verbose", `Lib settings of [${lib.name}] is overrided.`);
        }
      });
      let relativePath = path.relative(server.workingPath, appPath);
      server.log("verbose", `Loading lib [${lib.name}] from "${relativePath}" ...`);
      await lib.start_();
      server.registerLib(lib);
      server.log("verbose", `Lib [${lib.name}] is loaded.`);
    });
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mZWF0dXJlcy9saWJNb2R1bGVzLmpzIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiXyIsImVhY2hBc3luY18iLCJmcyIsIkZlYXR1cmUiLCJJbnZhbGlkQ29uZmlndXJhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0eXBlIiwiUExVR0lOIiwibG9hZF8iLCJzZXJ2ZXIiLCJlbnRyaWVzIiwiTGliTW9kdWxlIiwidHJ5UmVxdWlyZSIsImNvbmZpZyIsIm5hbWUiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwiZW52IiwibG9nV2l0aEFwcE5hbWUiLCJhcHBQYXRoIiwibnBtTW9kdWxlIiwidG9BYnNvbHV0ZVBhdGgiLCJhcHBNb2R1bGVzUGF0aCIsImpvaW4iLCJleGlzdHMiLCJwYXRoRXhpc3RzIiwic3RhdCIsImlzRGlyZWN0b3J5IiwibGliIiwib24iLCJpc0VtcHR5Iiwic2V0dGluZ3MiLCJsb2ciLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsIndvcmtpbmdQYXRoIiwic3RhcnRfIiwicmVnaXN0ZXJMaWIiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBbUJBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxDQUFGO0FBQUtDLEVBQUFBO0FBQUwsSUFBb0JGLE9BQU8sQ0FBQyxZQUFELENBQWpDOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUFTSCxPQUFPLENBQUMsV0FBRCxDQUF0Qjs7QUFDQSxNQUFNSSxPQUFPLEdBQUdKLE9BQU8sQ0FBQyxpQkFBRCxDQUF2Qjs7QUFDQSxNQUFNO0FBQUVLLEVBQUFBO0FBQUYsSUFBMkJMLE9BQU8sQ0FBQyxhQUFELENBQXhDOztBQUVBTSxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFLYkMsRUFBQUEsSUFBSSxFQUFFSixPQUFPLENBQUNLLE1BTEQ7QUFhYkMsRUFBQUEsS0FBSyxFQUFFLE9BQU9DLE1BQVAsRUFBZUMsT0FBZixLQUEyQjtBQUM5QixVQUFNO0FBQUVDLE1BQUFBO0FBQUYsUUFBZ0JGLE1BQU0sQ0FBQ0csVUFBUCxDQUFrQixjQUFsQixDQUF0QjtBQUVBLFdBQU9aLFVBQVUsQ0FBQ1UsT0FBRCxFQUFVLE9BQU9HLE1BQVAsRUFBZUMsSUFBZixLQUF3QjtBQUMvQyxVQUFJQyxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBUCxDQUNWO0FBQ0lDLFFBQUFBLEdBQUcsRUFBRVQsTUFBTSxDQUFDUyxHQURoQjtBQUVJQyxRQUFBQSxjQUFjLEVBQUVWLE1BQU0sQ0FBQ00sT0FBUCxDQUFlSTtBQUZuQyxPQURVLEVBS1ZOLE1BQU0sQ0FBQ0UsT0FMRyxDQUFkO0FBUUEsVUFBSUssT0FBSjs7QUFFQSxVQUFJUCxNQUFNLENBQUNRLFNBQVgsRUFBc0I7QUFDbEJELFFBQUFBLE9BQU8sR0FBR1gsTUFBTSxDQUFDYSxjQUFQLENBQXNCLGNBQXRCLEVBQXNDUixJQUF0QyxDQUFWO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsY0FBTVMsY0FBYyxHQUFHZCxNQUFNLENBQUNjLGNBQVAsSUFBeUJkLE1BQU0sQ0FBQ2EsY0FBUCxDQUFzQmIsTUFBTSxDQUFDTSxPQUFQLENBQWVRLGNBQXJDLENBQWhEO0FBQ0FILFFBQUFBLE9BQU8sR0FBR3ZCLElBQUksQ0FBQzJCLElBQUwsQ0FBVUQsY0FBVixFQUEwQlQsSUFBMUIsQ0FBVjtBQUNIOztBQUVELFVBQUlXLE1BQU0sR0FBRyxDQUFDLE1BQU14QixFQUFFLENBQUN5QixVQUFILENBQWNOLE9BQWQsQ0FBUCxLQUFrQyxDQUFDLE1BQU1uQixFQUFFLENBQUMwQixJQUFILENBQVFQLE9BQVIsQ0FBUCxFQUF5QlEsV0FBekIsRUFBL0M7O0FBQ0EsVUFBSSxDQUFDSCxNQUFMLEVBQWE7QUFDVCxjQUFNLElBQUl0QixvQkFBSixDQUEwQixRQUFPVyxJQUFLLGVBQXRDLEVBQXNETCxNQUF0RCxFQUErRCxjQUFhSyxJQUFLLEVBQWpGLENBQU47QUFDSDs7QUFFRCxVQUFJZSxHQUFHLEdBQUcsSUFBSWxCLFNBQUosQ0FBY0YsTUFBZCxFQUFzQkssSUFBdEIsRUFBNEJNLE9BQTVCLEVBQXFDTCxPQUFyQyxDQUFWO0FBRUFjLE1BQUFBLEdBQUcsQ0FBQ0MsRUFBSixDQUFPLGNBQVAsRUFBdUIsTUFBTTtBQUN6QixZQUFJLENBQUMvQixDQUFDLENBQUNnQyxPQUFGLENBQVVsQixNQUFNLENBQUNtQixRQUFqQixDQUFMLEVBQWlDO0FBQzdCSCxVQUFBQSxHQUFHLENBQUNoQixNQUFKLENBQVdtQixRQUFYLEdBQXNCaEIsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQlksR0FBRyxDQUFDaEIsTUFBSixDQUFXbUIsUUFBN0IsRUFBdUNuQixNQUFNLENBQUNtQixRQUE5QyxDQUF0QjtBQUNBdkIsVUFBQUEsTUFBTSxDQUFDd0IsR0FBUCxDQUFXLFNBQVgsRUFBdUIsb0JBQW1CSixHQUFHLENBQUNmLElBQUssaUJBQW5EO0FBQ0g7QUFDSixPQUxEO0FBT0EsVUFBSW9CLFlBQVksR0FBR3JDLElBQUksQ0FBQ3NDLFFBQUwsQ0FBYzFCLE1BQU0sQ0FBQzJCLFdBQXJCLEVBQWtDaEIsT0FBbEMsQ0FBbkI7QUFDQVgsTUFBQUEsTUFBTSxDQUFDd0IsR0FBUCxDQUFXLFNBQVgsRUFBdUIsZ0JBQWVKLEdBQUcsQ0FBQ2YsSUFBSyxXQUFVb0IsWUFBYSxPQUF0RTtBQUVBLFlBQU1MLEdBQUcsQ0FBQ1EsTUFBSixFQUFOO0FBRUE1QixNQUFBQSxNQUFNLENBQUM2QixXQUFQLENBQW1CVCxHQUFuQjtBQUVBcEIsTUFBQUEsTUFBTSxDQUFDd0IsR0FBUCxDQUFXLFNBQVgsRUFBdUIsUUFBT0osR0FBRyxDQUFDZixJQUFLLGNBQXZDO0FBQ0gsS0F4Q2dCLENBQWpCO0FBeUNIO0FBekRZLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTG9hZCBsaWIgbW9kdWxlc1xuICogQG1vZHVsZSBGZWF0dXJlX0xpYk1vZHVsZXNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAnbGliTW9kdWxlcyc6IHtcbiAqICAgICAgJzxuYW1lPic6IHtcbiAqICAgICAgICAgIG5wbU1vZHVsZTogZmFsc2UsIC8vIHdoZXRoZXIgaXMgYSBucG0gbW9kdWxlXG4gKiAgICAgICAgICBvcHRpb25zOiB7IC8vIG1vZHVsZSBvcHRpb25zXG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAgc2V0dGluZ3M6IHsgLy8gY2FuIG92ZXJyaWRlIG1vZHVsZSBkZWZpbmVkIHNldHRpbmdzXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqICB9XG4gKi9cblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgeyBfLCBlYWNoQXN5bmNfIH0gPSByZXF1aXJlKFwiQGdlbngvanVseVwiKTtcbmNvbnN0IHsgZnMgfSA9IHJlcXVpcmUoXCJAZ2VueC9zeXNcIik7XG5jb25zdCBGZWF0dXJlID0gcmVxdWlyZShcIi4uL2VudW0vRmVhdHVyZVwiKTtcbmNvbnN0IHsgSW52YWxpZENvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoXCJAZ2VueC9lcnJvclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIGxvYWRlZCBhdCBwbHVnaW4gc3RhZ2UuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHR5cGU6IEZlYXR1cmUuUExVR0lOLFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgZmVhdHVyZS5cbiAgICAgKiBAcGFyYW0ge1dlYlNlcnZlcn0gc2VydmVyIC0gVGhlIHdlYiBzZXJ2ZXIgbW9kdWxlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZW50cmllcyAtIExpYiBtb2R1bGUgZW50cmllcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Kj59XG4gICAgICovXG4gICAgbG9hZF86IGFzeW5jIChzZXJ2ZXIsIGVudHJpZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBMaWJNb2R1bGUgfSA9IHNlcnZlci50cnlSZXF1aXJlKCdAZ2VueC9zZXJ2ZXInKTtcblxuICAgICAgICByZXR1cm4gZWFjaEFzeW5jXyhlbnRyaWVzLCBhc3luYyAoY29uZmlnLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbnY6IHNlcnZlci5lbnYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ1dpdGhBcHBOYW1lOiBzZXJ2ZXIub3B0aW9ucy5sb2dXaXRoQXBwTmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZy5vcHRpb25zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgYXBwUGF0aDtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5ucG1Nb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBhcHBQYXRoID0gc2VydmVyLnRvQWJzb2x1dGVQYXRoKFwibm9kZV9tb2R1bGVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBNb2R1bGVzUGF0aCA9IHNlcnZlci5hcHBNb2R1bGVzUGF0aCB8fCBzZXJ2ZXIudG9BYnNvbHV0ZVBhdGgoc2VydmVyLm9wdGlvbnMuYXBwTW9kdWxlc1BhdGgpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhcHBQYXRoID0gcGF0aC5qb2luKGFwcE1vZHVsZXNQYXRoLCBuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGV4aXN0cyA9IChhd2FpdCBmcy5wYXRoRXhpc3RzKGFwcFBhdGgpKSAmJiAoYXdhaXQgZnMuc3RhdChhcHBQYXRoKSkuaXNEaXJlY3RvcnkoKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb25maWd1cmF0aW9uKGBMaWIgWyR7bmFtZX1dIG5vdCBleGlzdHMuYCwgc2VydmVyLCBgbGliTW9kdWxlcy4ke25hbWV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBsaWIgPSBuZXcgTGliTW9kdWxlKHNlcnZlciwgbmFtZSwgYXBwUGF0aCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGxpYi5vbihcImNvbmZpZ0xvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkoY29uZmlnLnNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBsaWIuY29uZmlnLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgbGliLmNvbmZpZy5zZXR0aW5ncywgY29uZmlnLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLmxvZyhcInZlcmJvc2VcIiwgYExpYiBzZXR0aW5ncyBvZiBbJHtsaWIubmFtZX1dIGlzIG92ZXJyaWRlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUoc2VydmVyLndvcmtpbmdQYXRoLCBhcHBQYXRoKTtcbiAgICAgICAgICAgIHNlcnZlci5sb2coXCJ2ZXJib3NlXCIsIGBMb2FkaW5nIGxpYiBbJHtsaWIubmFtZX1dIGZyb20gXCIke3JlbGF0aXZlUGF0aH1cIiAuLi5gKTtcblxuICAgICAgICAgICAgYXdhaXQgbGliLnN0YXJ0XygpO1xuXG4gICAgICAgICAgICBzZXJ2ZXIucmVnaXN0ZXJMaWIobGliKTtcblxuICAgICAgICAgICAgc2VydmVyLmxvZyhcInZlcmJvc2VcIiwgYExpYiBbJHtsaWIubmFtZX1dIGlzIGxvYWRlZC5gKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG4iXX0=