"use strict";

require("source-map-support/register");

const path = require('path');

const {
  _,
  pascalCase
} = require('rk-utils');

const {
  InvalidConfiguration
} = require('../utils/Errors');

const Feature = require('../enum/Feature');

const Literal = require('../enum/Literal');

module.exports = {
  type: Feature.INIT,
  load_: async (app, dbRefs) => {
    const DbCache = {};

    app.db = schemaName => {
      if (DbCache[schemaName]) return DbCache[schemaName];
      let schemaInfo = dbRefs[schemaName];

      if (!schemaInfo || !schemaInfo.fromLib && !schemaInfo.dataSource) {
        throw new InvalidConfiguration('Missing "lib" or "dataSource".', app, {
          'useDb': dbRefs,
          requestedSchema: schemaName
        });
      }

      let db;

      if (schemaInfo.fromLib) {
        let refSchemaName = schemaInfo.schemaName || schemaName;
        let lib = (app.server || app).getLib(schemaInfo.fromLib);
        db = lib.db(refSchemaName);
      } else {
        let connector = app.getService(schemaInfo.dataSource);

        if (!connector) {
          throw new InvalidConfiguration(`Data source [${schemaInfo.dataSource}] not found.`, app, `useDb.${schemaName}.dataSource`);
        }

        let i18n = app.getService('i18n') || app.__;

        let modelPath;

        if (app.options.modelPath) {
          modelPath = app.toAbsolutePath(app.options.modelPath);
        } else if (app.backendPath) {
          modelPath = path.join(app.backendPath, Literal.MODELS_PATH);
        } else {
          modelPath = app.toAbsolutePath(Literal.MODELS_PATH);
        }

        const Db = require(path.join(modelPath, pascalCase(schemaName)));

        db = new Db(app, connector, i18n);
      }

      DbCache[schemaName] = db;
      return db;
    };

    app.model = (schemaName, modelName) => {
      if (!modelName) {
        let [s, m] = schemaName.split('.');
        schemaName = s;
        modelName = m;
      }

      return app.db(schemaName).model(modelName);
    };
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mZWF0dXJlcy91c2VEYi5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIl8iLCJwYXNjYWxDYXNlIiwiSW52YWxpZENvbmZpZ3VyYXRpb24iLCJGZWF0dXJlIiwiTGl0ZXJhbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0eXBlIiwiSU5JVCIsImxvYWRfIiwiYXBwIiwiZGJSZWZzIiwiRGJDYWNoZSIsImRiIiwic2NoZW1hTmFtZSIsInNjaGVtYUluZm8iLCJmcm9tTGliIiwiZGF0YVNvdXJjZSIsInJlcXVlc3RlZFNjaGVtYSIsInJlZlNjaGVtYU5hbWUiLCJsaWIiLCJzZXJ2ZXIiLCJnZXRMaWIiLCJjb25uZWN0b3IiLCJnZXRTZXJ2aWNlIiwiaTE4biIsIl9fIiwibW9kZWxQYXRoIiwib3B0aW9ucyIsInRvQWJzb2x1dGVQYXRoIiwiYmFja2VuZFBhdGgiLCJqb2luIiwiTU9ERUxTX1BBVEgiLCJEYiIsIm1vZGVsIiwibW9kZWxOYW1lIiwicyIsIm0iLCJzcGxpdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFPQSxNQUFNQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUMsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQTtBQUFMLElBQW9CRixPQUFPLENBQUMsVUFBRCxDQUFqQzs7QUFDQSxNQUFNO0FBQUVHLEVBQUFBO0FBQUYsSUFBMkJILE9BQU8sQ0FBQyxpQkFBRCxDQUF4Qzs7QUFDQSxNQUFNSSxPQUFPLEdBQUdKLE9BQU8sQ0FBQyxpQkFBRCxDQUF2Qjs7QUFDQSxNQUFNSyxPQUFPLEdBQUdMLE9BQU8sQ0FBQyxpQkFBRCxDQUF2Qjs7QUFFQU0sTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBS2JDLEVBQUFBLElBQUksRUFBRUosT0FBTyxDQUFDSyxJQUxEO0FBYWJDLEVBQUFBLEtBQUssRUFBRSxPQUFPQyxHQUFQLEVBQVlDLE1BQVosS0FBdUI7QUFDMUIsVUFBTUMsT0FBTyxHQUFHLEVBQWhC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RUFBSixDQUFPQyxVQUFQLEVBQW1Cb0IsS0FBbkIsQ0FBeUJDLFNBQXpCLENBQVA7QUFDSCxLQVJEO0FBU0g7QUFsRVksQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBFbmFibGUgZGIgcmVmZXJlbmNlc1xuICogQG1vZHVsZSBGZWF0dXJlX1VzZURiXG4gKi9cblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgXywgcGFzY2FsQ2FzZSB9ID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IHsgSW52YWxpZENvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4uL3V0aWxzL0Vycm9ycycpO1xuY29uc3QgRmVhdHVyZSA9IHJlcXVpcmUoJy4uL2VudW0vRmVhdHVyZScpO1xuY29uc3QgTGl0ZXJhbCA9IHJlcXVpcmUoJy4uL2VudW0vTGl0ZXJhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZlYXR1cmUgaXMgbG9hZGVkIGF0IGluaXQgc3RhZ2VcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZTogRmVhdHVyZS5JTklULFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgZmVhdHVyZVxuICAgICAqIEBwYXJhbSB7QXBwfSBhcHAgLSBUaGUgYXBwIG1vZHVsZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGJSZWZzIC0gZGIgcmVmZXJlbmNlIHNldHRpbmdzICAgICBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Kj59XG4gICAgICovXG4gICAgbG9hZF86IGFzeW5jIChhcHAsIGRiUmVmcykgPT4ge1xuICAgICAgICBjb25zdCBEYkNhY2hlID0ge307XG4gICAgICAgIFxuICAgICAgICBhcHAuZGIgPSAoc2NoZW1hTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKERiQ2FjaGVbc2NoZW1hTmFtZV0pIHJldHVybiBEYkNhY2hlW3NjaGVtYU5hbWVdO1xuXG4gICAgICAgICAgICBsZXQgc2NoZW1hSW5mbyA9IGRiUmVmc1tzY2hlbWFOYW1lXTtcbiAgICAgICAgICAgIGlmICghc2NoZW1hSW5mbyB8fCAoIXNjaGVtYUluZm8uZnJvbUxpYiAmJiAhc2NoZW1hSW5mby5kYXRhU291cmNlKSkgeyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24oJ01pc3NpbmcgXCJsaWJcIiBvciBcImRhdGFTb3VyY2VcIi4nLCBhcHAsIHsgJ3VzZURiJzogZGJSZWZzLCByZXF1ZXN0ZWRTY2hlbWE6IHNjaGVtYU5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkYjtcblxuICAgICAgICAgICAgaWYgKHNjaGVtYUluZm8uZnJvbUxpYikge1xuICAgICAgICAgICAgICAgIGxldCByZWZTY2hlbWFOYW1lID0gc2NoZW1hSW5mby5zY2hlbWFOYW1lIHx8IHNjaGVtYU5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpYiA9IChhcHAuc2VydmVyIHx8IGFwcCkuZ2V0TGliKHNjaGVtYUluZm8uZnJvbUxpYik7XG5cbiAgICAgICAgICAgICAgICBkYiA9IGxpYi5kYihyZWZTY2hlbWFOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RvciA9IGFwcC5nZXRTZXJ2aWNlKHNjaGVtYUluZm8uZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb25maWd1cmF0aW9uKGBEYXRhIHNvdXJjZSBbJHtzY2hlbWFJbmZvLmRhdGFTb3VyY2V9XSBub3QgZm91bmQuYCwgYXBwLCBgdXNlRGIuJHtzY2hlbWFOYW1lfS5kYXRhU291cmNlYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGkxOG4gPSBhcHAuZ2V0U2VydmljZSgnaTE4bicpIHx8IGFwcC5fXztcbiAgICAgICAgICAgICAgICBsZXQgbW9kZWxQYXRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFwcC5vcHRpb25zLm1vZGVsUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFBhdGggPSBhcHAudG9BYnNvbHV0ZVBhdGgoYXBwLm9wdGlvbnMubW9kZWxQYXRoKTsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcHAuYmFja2VuZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxQYXRoID0gcGF0aC5qb2luKGFwcC5iYWNrZW5kUGF0aCwgTGl0ZXJhbC5NT0RFTFNfUEFUSCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxQYXRoID0gYXBwLnRvQWJzb2x1dGVQYXRoKExpdGVyYWwuTU9ERUxTX1BBVEgpOyBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBEYiA9IHJlcXVpcmUocGF0aC5qb2luKG1vZGVsUGF0aCwgcGFzY2FsQ2FzZShzY2hlbWFOYW1lKSkpO1xuICAgICAgICAgICAgICAgIGRiID0gbmV3IERiKGFwcCwgY29ubmVjdG9yLCBpMThuKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgICBEYkNhY2hlW3NjaGVtYU5hbWVdID0gZGI7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTsgICAgICAgXG4gICAgICAgIFxuICAgICAgICBhcHAubW9kZWwgPSAoc2NoZW1hTmFtZSwgbW9kZWxOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1vZGVsTmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBbIHMsIG0gXSA9IHNjaGVtYU5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBzY2hlbWFOYW1lID0gcztcbiAgICAgICAgICAgICAgICBtb2RlbE5hbWUgPSBtOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGFwcC5kYihzY2hlbWFOYW1lKS5tb2RlbChtb2RlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cbn07Il19