"use strict";

require("source-map-support/register");

const path = require('path');

const {
  naming
} = require('@genx/july');

const {
  InvalidConfiguration
} = require('@genx/error');

const Feature = require('../enum/Feature');

const Literal = require('../enum/Literal');

module.exports = {
  type: Feature.INIT,
  load_: async (app, dbRefs) => {
    const DbCache = {};

    app.db = schemaName => {
      if (DbCache[schemaName]) return DbCache[schemaName];
      let schemaInfo = dbRefs[schemaName];

      if (!schemaInfo) {
        throw new InvalidConfiguration(`Data source config for schema "${schemaName}" not found.`, app, {
          'useDb': dbRefs,
          requestedSchema: schemaName
        });
      }

      if (!schemaInfo.fromLib && !schemaInfo.dataSource) {
        throw new InvalidConfiguration('Missing "fromLib" or "dataSource".', app, {
          'useDb': dbRefs,
          requestedSchema: schemaName
        });
      }

      let db;

      if (schemaInfo.fromLib) {
        let refSchemaName = schemaInfo.schemaName || schemaName;
        let lib = (app.server || app).getLib(schemaInfo.fromLib);
        db = lib.db(refSchemaName);
      } else {
        let connector = app.getService(schemaInfo.dataSource);

        if (!connector) {
          throw new InvalidConfiguration(`Data source [${schemaInfo.dataSource}] not found.`, app, `useDb.${schemaName}.dataSource`);
        }

        let i18n = app.getService('i18n') || app.__;

        let modelPath;

        if (app.options.modelPath) {
          modelPath = app.toAbsolutePath(app.options.modelPath);
        } else if (app.backendPath) {
          modelPath = path.join(app.backendPath, Literal.MODELS_PATH);
        } else {
          modelPath = app.toAbsolutePath(Literal.MODELS_PATH);
        }

        const Db = require(path.join(modelPath, naming.pascalCase(schemaName)));

        db = new Db(app, connector, i18n);
      }

      DbCache[schemaName] = db;
      return db;
    };

    app.model = (schemaName, modelName) => {
      if (!modelName) {
        let [s, m] = schemaName.split('.');
        schemaName = s;
        modelName = m;
      }

      return app.db(schemaName).model(modelName);
    };
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mZWF0dXJlcy91c2VEYi5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIm5hbWluZyIsIkludmFsaWRDb25maWd1cmF0aW9uIiwiRmVhdHVyZSIsIkxpdGVyYWwiLCJtb2R1bGUiLCJleHBvcnRzIiwidHlwZSIsIklOSVQiLCJsb2FkXyIsImFwcCIsImRiUmVmcyIsIkRiQ2FjaGUiLCJkYiIsInNjaGVtYU5hbWUiLCJzY2hlbWFJbmZvIiwicmVxdWVzdGVkU2NoZW1hIiwiZnJvbUxpYiIsImRhdGFTb3VyY2UiLCJyZWZTY2hlbWFOYW1lIiwibGliIiwic2VydmVyIiwiZ2V0TGliIiwiY29ubmVjdG9yIiwiZ2V0U2VydmljZSIsImkxOG4iLCJfXyIsIm1vZGVsUGF0aCIsIm9wdGlvbnMiLCJ0b0Fic29sdXRlUGF0aCIsImJhY2tlbmRQYXRoIiwiam9pbiIsIk1PREVMU19QQVRIIiwiRGIiLCJwYXNjYWxDYXNlIiwibW9kZWwiLCJtb2RlbE5hbWUiLCJzIiwibSIsInNwbGl0Il0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQU9BLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQTtBQUFGLElBQWFELE9BQU8sQ0FBQyxZQUFELENBQTFCOztBQUNBLE1BQU07QUFBRUUsRUFBQUE7QUFBRixJQUEyQkYsT0FBTyxDQUFDLGFBQUQsQ0FBeEM7O0FBQ0EsTUFBTUcsT0FBTyxHQUFHSCxPQUFPLENBQUMsaUJBQUQsQ0FBdkI7O0FBQ0EsTUFBTUksT0FBTyxHQUFHSixPQUFPLENBQUMsaUJBQUQsQ0FBdkI7O0FBRUFLLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUtiQyxFQUFBQSxJQUFJLEVBQUVKLE9BQU8sQ0FBQ0ssSUFMRDtBQWFiQyxFQUFBQSxLQUFLLEVBQUUsT0FBT0MsR0FBUCxFQUFZQyxNQUFaLEtBQXVCO0FBQzFCLFVBQU1DLE9BQU8sR0FBRyxFQUFoQjs7QUFFQUYsSUFBQUEs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QUYsRUFBS0MsQ0FBTCxJQUFXeEIsVUFBVSxDQUFDeUIsS0FBWCxDQUFpQixHQUFqQixDQUFmO0FBQ0F6QixRQUFBQSxVQUFVLEdBQUd1QixDQUFiO0FBQ0FELFFBQUFBLFNBQVMsR0FBR0UsQ0FBWjtBQUNIOztBQUVELGFBQU81QixHQUFHLENBQUNHLEVBQUosQ0FBT0MsVUFBUCxFQUFtQnFCLEtBQW5CLENBQXlCQyxTQUF6QixDQUFQO0FBQ0gsS0FSRDtBQVNIO0FBdEVZLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRW5hYmxlIGRiIHJlZmVyZW5jZXNcbiAqIEBtb2R1bGUgRmVhdHVyZV9Vc2VEYlxuICovXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IG5hbWluZyB9ID0gcmVxdWlyZSgnQGdlbngvanVseScpO1xuY29uc3QgeyBJbnZhbGlkQ29uZmlndXJhdGlvbiB9ID0gcmVxdWlyZSgnQGdlbngvZXJyb3InKTtcbmNvbnN0IEZlYXR1cmUgPSByZXF1aXJlKCcuLi9lbnVtL0ZlYXR1cmUnKTtcbmNvbnN0IExpdGVyYWwgPSByZXF1aXJlKCcuLi9lbnVtL0xpdGVyYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIGxvYWRlZCBhdCBpbml0IHN0YWdlXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHR5cGU6IEZlYXR1cmUuSU5JVCxcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGZlYXR1cmVcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwIC0gVGhlIGFwcCBtb2R1bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRiUmVmcyAtIGRiIHJlZmVyZW5jZSBzZXR0aW5ncyAgICAgXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPCo+fVxuICAgICAqL1xuICAgIGxvYWRfOiBhc3luYyAoYXBwLCBkYlJlZnMpID0+IHtcbiAgICAgICAgY29uc3QgRGJDYWNoZSA9IHt9O1xuICAgICAgICBcbiAgICAgICAgYXBwLmRiID0gKHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChEYkNhY2hlW3NjaGVtYU5hbWVdKSByZXR1cm4gRGJDYWNoZVtzY2hlbWFOYW1lXTtcblxuICAgICAgICAgICAgbGV0IHNjaGVtYUluZm8gPSBkYlJlZnNbc2NoZW1hTmFtZV07XG4gICAgICAgICAgICBpZiAoIXNjaGVtYUluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24oYERhdGEgc291cmNlIGNvbmZpZyBmb3Igc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIG5vdCBmb3VuZC5gLCBhcHAsIHsgJ3VzZURiJzogZGJSZWZzLCByZXF1ZXN0ZWRTY2hlbWE6IHNjaGVtYU5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hSW5mby5mcm9tTGliICYmICFzY2hlbWFJbmZvLmRhdGFTb3VyY2UpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb25maWd1cmF0aW9uKCdNaXNzaW5nIFwiZnJvbUxpYlwiIG9yIFwiZGF0YVNvdXJjZVwiLicsIGFwcCwgeyAndXNlRGInOiBkYlJlZnMsIHJlcXVlc3RlZFNjaGVtYTogc2NoZW1hTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRiO1xuXG4gICAgICAgICAgICBpZiAoc2NoZW1hSW5mby5mcm9tTGliKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlZlNjaGVtYU5hbWUgPSBzY2hlbWFJbmZvLnNjaGVtYU5hbWUgfHwgc2NoZW1hTmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgbGliID0gKGFwcC5zZXJ2ZXIgfHwgYXBwKS5nZXRMaWIoc2NoZW1hSW5mby5mcm9tTGliKTtcblxuICAgICAgICAgICAgICAgIGRiID0gbGliLmRiKHJlZlNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdG9yID0gYXBwLmdldFNlcnZpY2Uoc2NoZW1hSW5mby5kYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24oYERhdGEgc291cmNlIFske3NjaGVtYUluZm8uZGF0YVNvdXJjZX1dIG5vdCBmb3VuZC5gLCBhcHAsIGB1c2VEYi4ke3NjaGVtYU5hbWV9LmRhdGFTb3VyY2VgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaTE4biA9IGFwcC5nZXRTZXJ2aWNlKCdpMThuJykgfHwgYXBwLl9fO1xuICAgICAgICAgICAgICAgIGxldCBtb2RlbFBhdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXBwLm9wdGlvbnMubW9kZWxQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsUGF0aCA9IGFwcC50b0Fic29sdXRlUGF0aChhcHAub3B0aW9ucy5tb2RlbFBhdGgpOyBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwcC5iYWNrZW5kUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFBhdGggPSBwYXRoLmpvaW4oYXBwLmJhY2tlbmRQYXRoLCBMaXRlcmFsLk1PREVMU19QQVRIKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFBhdGggPSBhcHAudG9BYnNvbHV0ZVBhdGgoTGl0ZXJhbC5NT0RFTFNfUEFUSCk7IFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IERiID0gcmVxdWlyZShwYXRoLmpvaW4obW9kZWxQYXRoLCBuYW1pbmcucGFzY2FsQ2FzZShzY2hlbWFOYW1lKSkpO1xuICAgICAgICAgICAgICAgIGRiID0gbmV3IERiKGFwcCwgY29ubmVjdG9yLCBpMThuKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgICBEYkNhY2hlW3NjaGVtYU5hbWVdID0gZGI7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTsgICAgICAgXG4gICAgICAgIFxuICAgICAgICBhcHAubW9kZWwgPSAoc2NoZW1hTmFtZSwgbW9kZWxOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1vZGVsTmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBbIHMsIG0gXSA9IHNjaGVtYU5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBzY2hlbWFOYW1lID0gcztcbiAgICAgICAgICAgICAgICBtb2RlbE5hbWUgPSBtOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGFwcC5kYihzY2hlbWFOYW1lKS5tb2RlbChtb2RlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cbn07Il19