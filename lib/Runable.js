"use strict";

require("source-map-support/register");

const Util = require('rk-utils');

const {
  _,
  Promise
} = Util;

const winston = require('winston');

const winstonFlight = require('winstonflight');

const Logger = require('winston/lib/winston/logger');

const Runable = T => {
  var _temp;

  return _temp = class extends T {
    constructor(name, options) {
      super(name, {
        logger: {
          "useMetaKey": "metadata",
          "level": "info",
          "transports": [{
            "type": "console",
            "options": {
              "format": winston.format.combine(winston.format.colorize(), winston.format.simple())
            }
          }],
          ...(options && options.logger)
        },
        ..._.omit(options, ['logger'])
      });

      this._onUncaughtException = err => {
        let waitForLogging = setTimeout(() => {
          process.exit(1);
        }, 1000);
        this.log('error', err, () => {
          clearTimeout(waitForLogging);
          process.exit(1);
        });
      };

      this._onWarning = warning => {
        this.log('warn', warning);
      };

      this._onExit = code => {
        if (this.started) {
          this.stop_().catch(this.logError);
        }
      };
    }

    async start_() {
      this._initialize();

      process.on('exit', this._onExit);
      return super.start_();
    }

    async stop_() {
      process.removeListener('exit', this._onExit);
      await super.stop_();
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          this._uninitialize();

          resolve(this);
        }, 0);
      });
    }

    replaceLogger(logger) {
      if (logger) {
        if (!!this._loggerBackup) {
          throw new Error("Assertion failed: !this._loggerBackup");
        }

        this._loggerBackup = this.logger;
        this._externalLoggerBackup = this._externalLogger;
        this.logger = logger;
        this._externalLogger = true;
        this.log('verbose', 'A new app logger attached.');
      } else {
        if (!this._loggerBackup) {
          throw new Error("Assertion failed: this._loggerBackup");
        }

        this.logger = this._loggerBackup;
        this._externalLogger = this._externalLoggerBackup;
        delete this._loggerBackup;
        delete this._externalLoggerBackup;
        this.log('verbose', 'The current app logger is dettached.');
      }
    }

    _initialize() {
      this._pwd = process.cwd();

      if (this.workingPath !== this._pwd) {
        process.chdir(this.workingPath);
      }

      this._injectLogger();

      this._injectErrorHandlers();
    }

    _uninitialize() {
      const detach = true;

      this._injectErrorHandlers(detach);

      this._injectLogger(detach);

      process.chdir(this._pwd);
      delete this._pwd;
    }

    _injectLogger(detach) {
      if (detach) {
        this.log('verbose', 'Logger is detaching ...');

        if (!this._externalLogger) {
          this.logger.close();
        }

        delete this._externalLogger;
        delete this.logger;
        return;
      }

      let loggerOpt = this.options.logger;

      if (loggerOpt instanceof Logger) {
        this.logger = loggerOpt;
        this._externalLogger = true;
      } else {
        if (loggerOpt.transports) {
          loggerOpt.transports = winstonFlight(winston, loggerOpt.transports);
        }

        this.logger = winston.createLogger(loggerOpt);
      }

      this.log('verbose', 'Logger injected.');
    }

    _injectErrorHandlers(detach) {
      if (detach) {
        this.log('verbose', 'Process-wide error handlers are detaching ...');
        process.removeListener('warning', this._onWarning);
        process.removeListener('uncaughtException', this._onUncaughtException);
        return;
      }

      process.on('uncaughtException', this._onUncaughtException);
      process.on('warning', this._onWarning);
      this.log('verbose', 'Process-wide error handlers injected.');
    }

  }, _temp;
};

module.exports = Runable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SdW5hYmxlLmpzIl0sIm5hbWVzIjpbIlV0aWwiLCJyZXF1aXJlIiwiXyIsIlByb21pc2UiLCJ3aW5zdG9uIiwid2luc3RvbkZsaWdodCIsIkxvZ2dlciIsIlJ1bmFibGUiLCJUIiwiY29uc3RydWN0b3IiLCJuYW1lIiwib3B0aW9ucyIsImxvZ2dlciIsImZvcm1hdCIsImNvbWJpbmUiLCJjb2xvcml6ZSIsInNpbXBsZSIsIm9taXQiLCJfb25VbmNhdWdodEV4Y2VwdGlvbiIsImVyciIsIndhaXRGb3JMb2dnaW5nIiwic2V0VGltZW91dCIsInByb2Nlc3MiLCJleGl0IiwibG9nIiwiY2xlYXJUaW1lb3V0IiwiX29uV2FybmluZyIsIndhcm5pbmciLCJfb25FeGl0IiwiY29kZSIsInN0YXJ0ZWQiLCJzdG9wXyIsImNhdGNoIiwibG9nRXJyb3IiLCJzdGFydF8iLCJfaW5pdGlhbGl6ZSIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJyZXNvbHZlIiwicmVqZWN0IiwiX3VuaW5pdGlhbGl6ZSIsInJlcGxhY2VMb2dnZXIiLCJfbG9nZ2VyQmFja3VwIiwiX2V4dGVybmFsTG9nZ2VyQmFja3VwIiwiX2V4dGVybmFsTG9nZ2VyIiwiX3B3ZCIsImN3ZCIsIndvcmtpbmdQYXRoIiwiY2hkaXIiLCJfaW5qZWN0TG9nZ2VyIiwiX2luamVjdEVycm9ySGFuZGxlcnMiLCJkZXRhY2giLCJjbG9zZSIsImxvZ2dlck9wdCIsInRyYW5zcG9ydHMiLCJjcmVhdGVMb2dnZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLFVBQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxDQUFGO0FBQUtDLEVBQUFBO0FBQUwsSUFBaUJILElBQXZCOztBQUVBLE1BQU1JLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFNBQUQsQ0FBdkI7O0FBQ0EsTUFBTUksYUFBYSxHQUFHSixPQUFPLENBQUMsZUFB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O0FBQ0gsWUFBSVMsU0FBUyxDQUFDQyxVQUFkLEVBQTBCO0FBQ3RCRCxVQUFBQSxTQUFTLENBQUNDLFVBQVYsR0FBdUJqRCxhQUFhLENBQUNELE9BQUQsRUFBVWlELFNBQVMsQ0FBQ0MsVUFBcEIsQ0FBcEM7QUFDSDs7QUFFRCxhQUFLMUMsTUFBTCxHQUFjUixPQUFPLENBQUNtRCxZQUFSLENBQXFCRixTQUFyQixDQUFkO0FBQ0g7O0FBRUQsV0FBSzdCLEdBQUwsQ0FBUyxTQUFULEVBQW9CLGtCQUFwQjtBQUNIOztBQUVEMEIsSUFBQUEsb0JBQW9CLENBQUNDLE1BQUQsRUFBUztBQUN6QixVQUFJQSxNQUFKLEVBQVk7QUFDUixhQUFLM0IsR0FBTCxDQUFTLFNBQVQsRUFBb0IsK0NBQXBCO0FBQ0FGLFFBQUFBLE9BQU8sQ0FBQ2UsY0FBUixDQUF1QixTQUF2QixFQUFrQyxLQUFLWCxVQUF2QztBQUNBSixRQUFBQSxPQUFPLENBQUNlLGNBQVIsQ0FBdUIsbUJBQXZCLEVBQTRDLEtBQUtuQixvQkFBakQ7QUFDQTtBQUNIOztBQUVESSxNQUFBQSxPQUFPLENBQUNjLEVBQVIsQ0FBVyxtQkFBWCxFQUFnQyxLQUFLbEIsb0JBQXJDO0FBQ0FJLE1BQUFBLE9BQU8sQ0FBQ2MsRUFBUixDQUFXLFNBQVgsRUFBc0IsS0FBS1YsVUFBM0I7QUFDQSxXQUFLRixHQUFMLENBQVMsU0FBVCxFQUFvQix1Q0FBcEI7QUFDSDs7QUF4S2dDLEdBQXBCO0FBQUEsQ0FBakI7O0FBMktBZ0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCbEQsT0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ3JrLXV0aWxzJyk7XG5jb25zdCB7IF8sIFByb21pc2UgfSA9IFV0aWw7XG5cbmNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XG5jb25zdCB3aW5zdG9uRmxpZ2h0ID0gcmVxdWlyZSgnd2luc3RvbmZsaWdodCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnd2luc3Rvbi9saWIvd2luc3Rvbi9sb2dnZXInKTtcblxuLyoqXG4gKiBSdW5hYmxlIGFwcCBtaXhpbi4gXG4gKiBAcGFyYW0ge29iamVjdH0gVCAtIEJhc2UgY2xhc3MuICAgICBcbiAqIEByZXR1cm5zIHtSdW5hYmxlfSBBIHJ1bmFibGUgYXBwIGNsYXNzLlxuICogQGNvbnN0cnVjdHMgUnVuYWJsZShUKVxuICovXG5jb25zdCBSdW5hYmxlID0gVCA9PiBjbGFzcyBleHRlbmRzIFQge1xuICAgIF9vblVuY2F1Z2h0RXhjZXB0aW9uID0gZXJyID0+IHtcbiAgICAgICAgbGV0IHdhaXRGb3JMb2dnaW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGVyciwgKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdhaXRGb3JMb2dnaW5nKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgICAgfSk7XG4gICAgfTsgICAgICAgIFxuXG4gICAgX29uV2FybmluZyA9IHdhcm5pbmcgPT4ge1xuICAgICAgICB0aGlzLmxvZygnd2FybicsIHdhcm5pbmcpOyAgIFxuICAgIH07XG5cbiAgICBfb25FeGl0ID0gY29kZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcF8oKS5jYXRjaCh0aGlzLmxvZ0Vycm9yKTtcbiAgICAgICAgfSAgICAgICAgICAgXG4gICAgfTtcblxuICAgIC8qKiAgICAgICAgICAgICAgICAgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24uICAgICBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gQXBwbGljYXRpb24gb3B0aW9ucyAgICAgXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zLmxvZ2dlcl0gLSBMb2dnZXIgb3B0aW9ucyAgICBcbiAgICAgKiBAY29uc3RydWN0cyBSdW5hYmxlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuYW1lLCB7XG4gICAgICAgICAgICBsb2dnZXI6IHtcbiAgICAgICAgICAgICAgICBcInVzZU1ldGFLZXlcIjogXCJtZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIFwibGV2ZWxcIjogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgXCJ0cmFuc3BvcnRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29uc29sZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogd2luc3Rvbi5mb3JtYXQuY29tYmluZSh3aW5zdG9uLmZvcm1hdC5jb2xvcml6ZSgpLCB3aW5zdG9uLmZvcm1hdC5zaW1wbGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLi4uKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2dnZXIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uXy5vbWl0KG9wdGlvbnMsIFsnbG9nZ2VyJ10pXG4gICAgICAgIH0pOyAgICAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGFwcCAgICAgXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQG1lbWJlcm9mIFJ1bmFibGVcbiAgICAgKi9cbiAgICBhc3luYyBzdGFydF8oKSB7ICAgICAgICBcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuXG4gICAgICAgIHByb2Nlc3Mub24oJ2V4aXQnLCB0aGlzLl9vbkV4aXQpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN1cGVyLnN0YXJ0XygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGFwcFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBtZW1iZXJvZiBSdW5hYmxlXG4gICAgICovXG4gICAgYXN5bmMgc3RvcF8oKSB7XG4gICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCB0aGlzLl9vbkV4aXQpO1xuXG4gICAgICAgIGF3YWl0IHN1cGVyLnN0b3BfKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vZGVmZXJyZWQgZXhlY3V0aW9uXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmluaXRpYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBsb2dnZXIgc2V0IG9uIGNyZWF0aW9uIG9mIHRoZSBhcHAuXG4gICAgICogQHBhcmFtIHtMb2dnZXJ9IGxvZ2dlciBcbiAgICAgKi9cbiAgICByZXBsYWNlTG9nZ2VyKGxvZ2dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgICAgICBhc3NlcnQ6ICF0aGlzLl9sb2dnZXJCYWNrdXA7XG5cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlckJhY2t1cCA9IHRoaXMubG9nZ2VyO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxMb2dnZXJCYWNrdXAgPSB0aGlzLl9leHRlcm5hbExvZ2dlcjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgICAgICB0aGlzLl9leHRlcm5hbExvZ2dlciA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMubG9nKCd2ZXJib3NlJywgJ0EgbmV3IGFwcCBsb2dnZXIgYXR0YWNoZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3JlcGxhY2UgYmFja1xuICAgICAgICAgICAgYXNzZXJ0OiB0aGlzLl9sb2dnZXJCYWNrdXA7XG5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5fbG9nZ2VyQmFja3VwO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxMb2dnZXIgPSB0aGlzLl9leHRlcm5hbExvZ2dlckJhY2t1cDtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvZ2dlckJhY2t1cDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9leHRlcm5hbExvZ2dlckJhY2t1cDtcblxuICAgICAgICAgICAgdGhpcy5sb2coJ3ZlcmJvc2UnLCAnVGhlIGN1cnJlbnQgYXBwIGxvZ2dlciBpcyBkZXR0YWNoZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5fcHdkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZ1BhdGggIT09IHRoaXMuX3B3ZCkgeyAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHByb2Nlc3MuY2hkaXIodGhpcy53b3JraW5nUGF0aCk7XG4gICAgICAgIH0gICAgICBcblxuICAgICAgICB0aGlzLl9pbmplY3RMb2dnZXIoKTtcbiAgICAgICAgdGhpcy5faW5qZWN0RXJyb3JIYW5kbGVycygpOyBcbiAgICB9XG5cbiAgICBfdW5pbml0aWFsaXplKCkge1xuICAgICAgICBjb25zdCBkZXRhY2ggPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbmplY3RFcnJvckhhbmRsZXJzKGRldGFjaCk7ICAgICAgIFxuICAgICAgICB0aGlzLl9pbmplY3RMb2dnZXIoZGV0YWNoKTsgICAgICAgICBcblxuICAgICAgICBwcm9jZXNzLmNoZGlyKHRoaXMuX3B3ZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wd2Q7XG4gICAgfVxuXG4gICAgX2luamVjdExvZ2dlcihkZXRhY2gpIHtcbiAgICAgICAgaWYgKGRldGFjaCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3ZlcmJvc2UnLCAnTG9nZ2VyIGlzIGRldGFjaGluZyAuLi4nKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9leHRlcm5hbExvZ2dlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9leHRlcm5hbExvZ2dlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb2dnZXJPcHQgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuXG4gICAgICAgIGlmIChsb2dnZXJPcHQgaW5zdGFuY2VvZiBMb2dnZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyT3B0O1xuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxMb2dnZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvZ2dlck9wdC50cmFuc3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyT3B0LnRyYW5zcG9ydHMgPSB3aW5zdG9uRmxpZ2h0KHdpbnN0b24sIGxvZ2dlck9wdC50cmFuc3BvcnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSB3aW5zdG9uLmNyZWF0ZUxvZ2dlcihsb2dnZXJPcHQpOyAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmxvZygndmVyYm9zZScsICdMb2dnZXIgaW5qZWN0ZWQuJyk7ICAgICAgICAgICAgXG4gICAgfVxuXG4gICAgX2luamVjdEVycm9ySGFuZGxlcnMoZGV0YWNoKSB7XG4gICAgICAgIGlmIChkZXRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd2ZXJib3NlJywgJ1Byb2Nlc3Mtd2lkZSBlcnJvciBoYW5kbGVycyBhcmUgZGV0YWNoaW5nIC4uLicpO1xuICAgICAgICAgICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignd2FybmluZycsIHRoaXMuX29uV2FybmluZyk7XG4gICAgICAgICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMuX29uVW5jYXVnaHRFeGNlcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB0aGlzLl9vblVuY2F1Z2h0RXhjZXB0aW9uKTsgXG4gICAgICAgIHByb2Nlc3Mub24oJ3dhcm5pbmcnLCB0aGlzLl9vbldhcm5pbmcpO1xuICAgICAgICB0aGlzLmxvZygndmVyYm9zZScsICdQcm9jZXNzLXdpZGUgZXJyb3IgaGFuZGxlcnMgaW5qZWN0ZWQuJyk7ICAgICAgICAgICAgXG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdW5hYmxlOyJdfQ==