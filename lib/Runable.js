"use strict";const Util=require("rk-utils");const{_,sleep_,eachAsync_}=Util;const winston=require("winston");const winstonFlight=require("winstonflight");const Logger=require("winston/lib/winston/logger");const Runable=T=>{var _temp;return _temp=class extends T{constructor(name,options){super(name,{logger:{"useMetaKey":"metadata","level":"info","transports":[{"type":"console","options":{"format":winston.format.combine(winston.format.colorize(),winston.format.simple())}}],...(options&&options.logger)},exitOnUncaught:true,..._.omit(options,["logger"])});this._getOnUncaughtException=exitOnError=>err=>{if(exitOnError){let waitForLogging=setTimeout(()=>{process.exit(1)},1000);this.log("error",err,()=>{clearTimeout(waitForLogging);process.exit(1)})}else{this.logError(err)}};this._onWarning=warning=>{this.log("warn",warning.message)};this._onExit=code=>{if(this.started){this.stop_().catch(this.logError)}}}async start_(){this._initialize();process.on("exit",this._onExit);return super.start_()}async stop_(){if(this.started){if(this.libModules){await eachAsync_(this.libModules,lib=>lib.stop_());delete this.libModules}}process.removeListener("exit",this._onExit);await super.stop_();await sleep_(0);this._uninitialize()}getLib(libName){if(!this.libModules){throw new Error("\"libModules\" feature is required to access lib among modules.")}let libModule=this.libModules[libName];if(!libModule){throw new Error(`Lib module [${libName}] not found.`)}return libModule}requireFromLib(libName,relativePath){let libModule=this.getLib(libName);return libModule.require(relativePath)}registerLib(lib){if(!this.libModules){this.libModules={}}this.libModules[lib.name]=lib}_initialize(){this._pwd=process.cwd();if(this.workingPath!==this._pwd){process.chdir(this.workingPath)}this._injectLogger();this._injectErrorHandlers()}_uninitialize(){const detach=true;this._injectErrorHandlers(detach);this._injectLogger(detach);process.chdir(this._pwd);delete this._pwd}_injectLogger(detach){if(detach){this.log("verbose","Logger is detaching ...");if(!this._externalLogger){this.logger.close()}delete this._externalLogger;delete this.logger;return}if(this.options.logger instanceof Logger){this.logger=this.options.logger;this._externalLogger=true}else{const loggerOpt=_.cloneDeep(this.options.logger);if(loggerOpt.transports){loggerOpt.transports=winstonFlight(winston,loggerOpt.transports)}this.logger=winston.createLogger(loggerOpt)}this.log("verbose","Logger injected.")}_injectErrorHandlers(detach){if(detach){process.removeListener("warning",this._onWarning);if(this._onUncaughtException){process.removeListener("uncaughtException",this._onUncaughtException);delete this._onUncaughtException}this.log("verbose","Process-wide error handlers detached.");return}if(!this.options.ignoreUncaught){this._onUncaughtException=this._getOnUncaughtException(this.options.exitOnUncaught);process.on("uncaughtException",this._onUncaughtException)}process.on("warning",this._onWarning);this.log("verbose","Process-wide error handlers injected.")}},_temp};module.exports=Runable;